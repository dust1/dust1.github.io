[{"title":"Mysql索引小节","url":"/2021/01/31/Mysql索引小节/","content":"索引是帮助Mysql高效获取数据的数据结构。索引可以和数据文件放一起，也可以单独成为一个索引文件。索引通常是B+树结构。\n\n索引的优势和劣势：\n优势：\n\t• 可以提高数据检索效率，降低IO成本。\n\t• 通过索引列对数据进行排序，降低排序成本，降低CPU消耗。\n\t\t○ 对索引列进行order by速度会快很多，因为索引保存的是数据的地址，而单独对索引与数据地址进行排序的开销比对数据进行排序的开销要少很多。\n\t\t○ 覆盖索引，不需要回表查询。索引列会保存在单独的索引树中，如果要查询的数据在索引树中就存在，则不需要根据数据地址再查询一遍数据。\n劣势：\n\t• 索引会占用磁盘空间\n\t• 索引会降低表更新效率，更新数据的同时还要更新索引。\n\n#### 索引的分类：\n##### 单列索引：\n\t• 普通索引：Mysql中的基本索引类型，没有限制，允许空值与重复\n\t• 唯一索引：允许为空，但不允许重复\n\t• 主键索引：不允许为空，不允许重复\n##### 组合索引：\n\t• 在表的多个字段上创建索引\n\t• 组合索引的使用遵循最左匹配原则\n\t• 一般情况下建议使用组合索引代替单列索引（主键索引除外）\n##### 全文索引：\n\t• 只能在CHAR、VARCHAR、TEXT等字段使用\n\t• 只在MyISAM、InnoDB（5.6以后）才能使用\n\t• 优先级最高，不会执行其他索引\n##### 空间索引：\n\t• 待补充\n\n#### 索引的存储结构：\n\t• 索引是在存储引擎中实现的，因此不同的存储引擎会使用不同的索引\n\t• MyISAM、InnoDB采用的是B+树索引\n\t\n> B树和B+树的主要区别在于子节点是否存储数据，B+树只在叶子阶段存储数据，且叶子结点都在同一层，并且节点之间通过指针关联\n\n#### 非聚集索引（MyISAM）：\n\t• B+树叶子结点存储的是数据行（数据文件）的指针，数据与索引不在一起。\n\t• 非聚集索引包含主键索引和辅助索引都会存储指针的值\n<img src=\"/img/202101/002.png\" width=\"50%\" height=\"50%\">\n通过主键索引查询到叶子结点后，叶子结点中存储的数据是指向数据行的指针，因此会查询两次。索引文件存储在.mdi中，数据文件存储在.ibd中。\n在MyISAN中，主键索引和辅助索引的区别只在于主键索引是唯一的，结构都是一样。\n\n#### 聚集索引（InnoDB）：\n\t• 主键索引的叶子结点会存储数据行，即数据和索引是在一起的\n\t• 辅助索引只会存储主键值。如果要用辅助索引查询，则先根据辅助索引获取到主键索引，然后再根据主键索引获取到数据行。\n\t• 如果没有主键，则使用唯一索引建立主键。如果没有唯一索引，则会按照一定规则自动创建主键，类型为长整型。\n<img src=\"/img/202101/001.png\" width=\"50%\" height=\"50%\">\n辅助索引保存的是主键的值，即引用主键。因此通过辅助索引查询到主键索引之后还要再根据主键索引查询行数据。这种行为叫做回表查询。\n\n因为辅助索引树保存的数据是索引的列的数据（这部分数据是值，而不是地址），所以如果只是需要查询索引相关的列，则这部分行数据已经存在于辅助索引树中，就不需要回表查询。\n\n例如：table1中id是主键、name是辅助索引、age是一般字段。则他的辅助索引树中保存着id和name的信息。\n当：\n> Select * from table1 where name = 'Bob'    需要回表查询，因为*表示所有数据，但是辅助索引树中只有id和name\n\n\n> Select id,name from table1 where name = 'Bob'    此时不需要回表查询，因为id和name的数据都在辅助索引树中就已经存在。\n\n\nQ:为什么不建议用过长的字段作为主键?\n\nA:因为辅助索引引用的都是主键索引，过长的主键会使得辅助索引树过大。\n\nQ:哪些情况下需要创建索引？\n\t1. 主键自动建立唯一索引\n\t2. 频繁作为查询条件的字段应该创建索引\n\t3. 多表关联查询中，关联字段需要创建索引 on 的两边都是。\n\t4. 查询中排序的字段需要创建索引\n\t5. 频繁查找的字段，创建覆盖索引\n\t6. 查询中统计或者分组的字段应该创建索引 group by\n\nQ:哪些情况下不需要创建索引？\n\t1. 表记录太少\n\t2. 经常进行增删改操作的表\n\t3. 频繁更新的字段\n\t4. where 条件中使用频率不高的字段\n\n\n#### 组合索引\nmysql创建组合索引的规则是首先会对组合索引的最左边第一个字段进行排序，并在此基础在再为第二个索引字段进行排序，类似于order by col1,col2这样的规则。\n组合索引相当于将多个列建立成一个辅助索引树，因此比多列创建单列索引更加节省空间。\n两者的区别：\n\t• 多列建立一棵索引树更加节省空间\n\t• 多列分别建立索引更容易实现覆盖索引\n\n组合索引使用时遵循最左前缀原则：\n\t• like语句在使用时使用前缀匹配的场合下会使用索引 like 'a%'\n\t• 当where语句遇到>、<、like、between时中断索引，即当语句where a = 1 and b = 2 and c > 3 and d = 4时，索引在c > 3处结束，不会调用d的索引。此时需要将创建组合索引时的顺序改变即可：将(a,b,c,d)修改为(a,b,d,c)，这样在调用语句的时候会自动将d = 4放到c > 3之前。\n\n#### 索引失败：\nmysql提供了explain命令对select语句进行分析，并输出直接结果。\n\nexplain执行返回的字段说明：\n\t• id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.\n\t• select_type: SELECT 查询的类型.\n\t• table: 查询的是哪个表\n\t• partitions: 匹配的分区\n\t• type: join 类型\n\t• possible_keys: 此次查询中可能选用的索引\n\t• key: 此次查询中确切使用到的索引.\n\t• ref: 哪个字段或常数与 key 一起被使用\n\t• rows: 显示此查询一共扫描了多少行. 这个是一个估计值.\n\t• filtered: 表示此查询条件所过滤的数据的百分比\n\t• extra: 额外的信息\n\n索引失败的几种情况：\n\t• 使用like的时候用后缀匹配，即 like '%a'，此时索引失效\n\t• or的前后没有同时使用索引，这里的索引只能是单列索引，如果or前后属于组合所以，则一样无法生效\n\t• 使用组合索引时没有使用第一列索引，导致索引失效。即组合索引是有顺序要求，他会在where条件中根据组合索引创建时的顺序重新排列查询条件，如果不存在第一列索引，则索引失效。\n\t• 数据类型出现隐式转换，如varchar不加单引号会自动转换为int型，使索引失效。\n\t• 在索引字段上使用了not，!=，<>。!=操作不会使用索引，它只会产生全盘扫描。优化方法：将其拆分为 key > 0 or key < 0\n\t• 对索引字段执行计算操作\n\t• 当全盘扫描比使用索引快时mysql会自动使用全盘扫描，此时索引失效。\n\n> 使用is null，is not null时，依旧会调用索引，mysql在选择是否使用索引时的一个依据就是全盘扫描和使用索引时的开销对比。\n\n"},{"title":"游戏世界中的数学工具","url":"/2020/12/06/游戏世界中的数学工具/","content":"游戏是在计算机上实时模拟虚拟世界的数学模型。\n\n虽然在游戏中会用到几乎所有的数学分支，但最常用的只有两种：三维矢量与矩阵。\n\n## 点和矢量\n物体在三维世界中的三个要素：\n1. 位置（position）\n2. 定向（orientation）\n3. 比例（scale）\n\n通过连续地修改这三个属性来实现动画效果，将物体变换（transform）至屏幕空间使得物体渲染到屏幕上。在游戏中三维物体几乎都是以三角形组成，三角形的三个顶点（vertex）用点（point）来表示。\n\n### 坐标系\n常用的坐标系有三种：\n1. 笛卡尔坐标：由x、y、z三根轴组成\n2. 圆柱坐标：垂直高度h，从垂直轴发射的辐射轴r，偏航角（yaw）角度θ组成\n3. 球坐标：俯视角（pitch）、偏航角（yaw）、半径长度组成\n\n<img src=\"/img/202012/001.png\" width=\"50%\" height=\"50%\">\n\n> 坐标系选用的例子：\n> Q:若要让物体向漩涡一样绕着主角旋转时用什么坐标系？\n> A:圆柱坐标。要绘制漩涡动画，只需要简单地在θ上加上恒定角速率，在辐射轴r上加入少许向内的恒定线性速率，在h上加上向上的恒定线性速率，物体就会慢慢地旋转向上到角色中\n\n### 矢量\n矢量由三个标量（x、y、z）组成，即若要在三维空间中表示一个点，至少需要3个参数。\n> 矢量**v** = [x, y, z]\n\n#### 笛卡尔基矢量\n笛卡尔积单位矢量：在笛卡尔坐标系中，沿着三根轴并且模为1的矢量成为笛卡尔积单位矢量，分别表现为:\n1. **i** = [1, 0, 0]\n2. **j** = [0, 1, 0]\n3. **k** = [0, 0, 1]\n\n在笛卡尔坐标系中的任意点或矢量都能用3个标量与三个基矢量乘积之和表示标量。例如[5 3 -2] = 5**i** + 3**j** - 2**k**。\n\n#### 矢量运算\n\n##### 矢量与标量乘法 - 矢量的缩放\n矢量**a**与标量s相乘，等于**a**中的每个分量和s相乘:\n<img src=\"/img/202012/002.png\" width=\"50%\" height=\"50%\">\n矢量与标量相乘表示矢量方向不变，缩放矢量的模，乘以-1表示将矢量方向反转（头尾互换）。其中，s被称为**缩放因子**(scale factor)，其中，矢量的每个轴的缩放因子也会不同，因此将矢量缩放时每个轴的缩放因子是否相同，将其分为：统一缩放和非统一缩放。非统一缩放可以表示为矢量与缩放矢量的分量积,设矢量**a**、缩放矢量**s**,则a的分量积公式如下：\n<img src=\"/img/202012/003.png\" width=\"50%\" height=\"50%\">\n\n* 统一缩放：表现为标量s乘以矢量**a**。\n* 非统一缩放：表现为两个矢量的分量积，分量积不等于两个矢量相乘。这种运算方式又被称为阿达马积。\n\n##### 矢量的加法与减法\n矢量的相加等于将两个矢量首尾相连后剩下首尾相连所形成的新的矢量。\n<img src=\"/img/202012/004.png\" width=\"50%\" height=\"50%\">\n\n矢量的相减等同于矢量加上另一个矢量的反方向矢量。\n<img src=\"/img/202012/005.png\" width=\"50%\" height=\"50%\">\n\n二者表现如下：\n<img src=\"/img/202012/006.png\" width=\"50%\" height=\"50%\">\n\n矢量与点的加减运算如下：\n* 方向 + 方向 = 方向\n* 方向 - 方向 = 方向\n* 点 + 方向 = 点\n* 点 - 点 = 方向\n* 点 + 点 = **无意义**\n\n##### 模\n矢量的模等于矢量的各个标量的平方和开根号。\n<img src=\"/img/202012/007.png\" width=\"50%\" height=\"50%\">\n类似于勾股定理，在二维空间中，z轴为0，则可以更加直观的看到矢量模的计算：\n<img src=\"/img/202012/008.png\" width=\"50%\" height=\"50%\">\n\n> 我们在进行模的比较的时候通常可以用模的平方来比较，这样可以减少开销\n\n##### 矢量运算的实际应用\n设某人工智能的角色所在位置为P1，其速度为**v**，则可以找到他的下一帧位置P2，方法是把**v**以△t缩放，再加上P1。等式为P2 = P1 + **v**△t。这称为**显式欧拉法**。其中速度**v**恒定才有效。\n<img src=\"/img/202012/009.png\" width=\"50%\" height=\"50%\">\n\n##### 归一化与单位矢量\n单位矢量：模为1的矢量\n\n给定一个矢量**v**，其模为v=|**v**|,将其转化为方向相同的单位矢量**u**的过程如下：\n<img src=\"/img/202012/010.png\" width=\"50%\" height=\"50%\">\n这个过程称之为**归一化**\n\n##### 法矢量\n在三维世界中，一个平面可以由平面上的一点P以及一个垂直于该平面的矢量组成。这个矢量又被称为**法矢量**。\n> 法矢量不等于单位矢量，他的模不一定为1\n\n##### 点积和投影\n矢量之间可以相乘，这种相乘跟上面所描述的*分量积*完全不同。通常最常用的乘法有两种：\n* 点积：又被称为标量积或内积\n* 叉积：又被称为矢量积或外积\n\n两个矢量的点积的结果是一个标量，这个标量等于两个矢量的各个标量相乘的和：\n<img src=\"/img/202012/011.png\" width=\"50%\" height=\"50%\">\n\n点积也可以写成两个矢量的模相乘后再乘以两个矢量之间夹角的余弦：\n<img src=\"/img/202012/012.png\" width=\"50%\" height=\"50%\">\n\n点积符合交换律，且在加法上符合分配律。\n\n若**u**是单位矢量，则矢量**a**与矢量**u**的点积等于在**u**所在的直线上矢量**a**的投影。\n<img src=\"/img/202012/013.png\" width=\"50%\" height=\"50%\">\n\n若矢量与自身相乘，由于矢量的夹角θ为0°，所谓cosθ=1，得矢量与自身的点积为矢量模的平方\n<img src=\"/img/202012/014.png\" width=\"50%\" height=\"50%\">\n\n点积通常用于判断两个矢量是否共线或垂直，也可用来判断两个矢量是否大致在相同或相反方向：\n* 共线：**a**·**b**=|**a**||**b**|=ab。夹角θ为0，cosθ=1\n* 共线但是方向相反：**a**·**b**=-ab。夹角θ为180，cosθ=-1\n* 垂直：**a**·**b**=0，cosθ=0\n* 相同方向：**a**·**b** > 0(即cosθ > 0,夹角小于90°)\n* 相反方向：**a**·**b** < 0(即cosθ < 0,夹角大于90°)\n\n<img src=\"/img/202012/015.png\" width=\"50%\" height=\"50%\">\n\n##### 叉积\n两个矢量的叉积会产生一个新的矢量，新的矢量垂直于相乘的两个矢量所组成的平面，因此，叉积只存在与三维空间。\n<img src=\"/img/202012/016.png\" width=\"50%\" height=\"50%\">\n\n叉积的模等于两个相乘矢量的模乘以两个矢量夹角的正弦。所以当两个矢量共线时，他们的叉积为0。\n<img src=\"/img/202012/017.png\" width=\"50%\" height=\"50%\">\n\n若两条矢量分别是平行四边形的两条边，则两个矢量的叉积等于这个平行四边形的面积。\n<img src=\"/img/202012/018.png\" width=\"50%\" height=\"50%\">\n\n叉积的方向根据所选择的坐标系法则有关，左右法则和右手法则会得到不同方向的叉积。\n\n叉积不符合交换律，叉积的先后顺序影响最终结果。但是符合反交换律。\n<img src=\"/img/202012/019.png\" width=\"50%\" height=\"50%\">\n\n在加法上符合分配律\n<img src=\"/img/202012/020.png\" width=\"50%\" height=\"50%\">\n\n根据叉积的性质，可以得到笛卡尔积之间互相转换的公式：\n<img src=\"/img/202012/021.png\" width=\"50%\" height=\"50%\">\n\n#### 点和矢量的线性插值\n在游戏中，为了保证两个点之间移动时的顺滑，需要得到点到点之间的的中间点。为了得到这个中间点的计算称为**线性插值**，通常简写成LERP。其定义如下，设从点**A**到点**B**，其中的中间点**L**与**A**的距离是**A**到**B**的距离的β（0 ≤ β ≤ 1）。则：\n<img src=\"/img/202012/022.png\" width=\"50%\" height=\"50%\">\n从几何上看效果如下：\n<img src=\"/img/202012/023.png\" width=\"50%\" height=\"50%\">\n\n## 矩阵\n矩阵（matrix）由mxn个标量组成的长方形数组，在游戏世界中方便用于表示旋转（transformaction）、平移（translation）、缩放（scale）。\n\n3x3的矩阵表示纯旋转；4x4的矩阵表示旋转、平移、缩放。\n\n### 矩阵乘法\n当两个矩阵的内维相等的时候才能相乘，设**A**为m × p的矩阵，**B**为p × n的矩阵，那么称m × n的矩阵**C**为矩阵**A**与**B**的乘积，记作**C**=**A**·**B**。\n新的矩阵的各个标量计算如下：\n<img src=\"/img/202012/024.png\" width=\"50%\" height=\"50%\">\n\n矩阵的乘法先后顺序影响最终结果，不符合乘法交换律。矩阵的乘法有时又被称为**串接**。因为矩阵表示一次变换，矩阵的相乘表示将多个变换串接起来。\n\n### 矩阵表示点和矢量\n点和矢量都可以表示为行矩阵（1 × n）或列矩阵（n × 1）。其中n表示使用中的空间纬度，通常是2或3.例如矢量**v**=(3 4 -1)可以写成\n<img src=\"/img/202012/025.png\" width=\"50%\" height=\"50%\">\n或\n<img src=\"/img/202012/026.png\" width=\"50%\" height=\"50%\">\n\n两种矩阵方式的选择会影响矩阵相乘的次序。因为矩阵相乘的时候，两个矩阵的内维需要相等。所以：\n* 要把1 × n行矢量乘以n × n矩阵，矢量必须置于矩阵的左方<img src=\"/img/202012/027.png\" width=\"50%\" height=\"50%\">\n* 要把n × n矩阵乘以n × 1列矩阵，矢量必须位于矩阵的右方<img src=\"/img/202012/028.png\" width=\"50%\" height=\"50%\">\n\n### 单位矩阵\n单位矩阵与其他任何矩阵**M**相乘都等于**M**本身。其表现为对角线元素都是1，其他元素都是0。通常写作**I**。\n<img src=\"/img/202012/029.png\" width=\"50%\" height=\"50%\">\n\n### 逆矩阵\n设一个矩阵为**A**，则它的逆矩阵表示为**A⁻¹**,逆矩阵能还原矩阵的变换。所以矩阵与其逆矩阵相乘结果是单位矩阵。通常用高斯消去法或LU分解求得。矩阵串街后求逆等于反向串接各个矩阵的逆矩阵。\n<img src=\"/img/202012/030.png\" width=\"50%\" height=\"50%\">\n\n### 转置矩阵\n矩阵**M**的转置写作**Mᵀ**,转置矩阵就是以原来矩阵的对称轴做反射。和逆矩阵一样，矩阵串接后的转置矩阵等于反向串街各个矩阵的转置矩阵。\n<img src=\"/img/202012/031.png\" width=\"50%\" height=\"50%\">\n\n转置矩阵有一个重要的特点：\n> 纯旋转的矩阵他的逆矩阵与转置矩阵是相同的\n\n因此基于此，通常用转置矩阵代替逆矩阵，因为求转置矩阵的速度比求逆矩阵快。\n\n### 齐次坐标\n当点或矢量从三维(3 × 3)延伸至四维(4 × 4)的过程称为**齐次坐标**。因为4 × 4矩阵能够同时表示旋转、平移、缩放，因此在游戏中最常用的就是4 × 4矩阵。\n\n三维空间中，若一个矢量**r**绕z轴旋转ø°，则可以表示为：\n<img src=\"/img/202012/032.png\" width=\"50%\" height=\"50%\">\n但是3 × 3矩阵无法表示平移与缩放，而4 × 4可以\n<img src=\"/img/202012/033.png\" width=\"50%\" height=\"50%\">\n\n### 变换方向矢量\n矩阵同时携带旋转、平移、缩放这三个变换信息，当矩阵作用在点上时，三者都可以产生作用。但是当用矩阵变换一个方向矢量时要忽略**平移**效果。因为方向矢量并不会产生平移，而且一旦平移就会改变他的模，这不是我们想要看到的。\n\n在方向矢量与矩阵相乘是，把矢量的齐次坐标中的ω设置成0即可。\n<img src=\"/img/202012/034.png\" width=\"50%\" height=\"50%\">\n\n在将四维的齐次坐标转化为三维的非齐次坐标的时候通常是将x、y、z分别除以ω，因此当ω为0的时候会产生无穷大，因为在三维空间中的纯方向矢量在四维空间中表示一个无限远的点。\n<img src=\"/img/202012/035.png\" width=\"50%\" height=\"50%\">\n\n### 基础变换矩阵\n从上可以知道4 × 4矩阵可以表示旋转、平移与缩放。他们的分布如下：\n<img src=\"/img/202012/036.png\" width=\"50%\" height=\"50%\">\n\n* 左上角的3 × 3矩阵**U**代表旋转或缩放\n* 1 × 3平移矢量**t**\n* 3 × 1矢量**O** = [0 0 0]ᵀ\n* 右下角标量1\n\n从中可以看到，最右边一列的标量都是常量，并不会随着矩阵的功能而改变，因此为了节省空间，在计算机中可以用4 × 3矩阵代替。\n\n### 坐标空间\n确定物体的具体坐标之前需要确定参照物用于构建坐标系，在三维游戏世界，根据参照物的不同将其分为三个坐标空间：世界空间、模型空间、观察空间。三者的区别如下：\n* 世界空间：以游戏世界中的某点为原点，游戏世界中所有物体都可以通过世界空间表示，这个坐标将所有物体联系起来组成虚拟世界。是一个固定坐标。\n* 模型空间：基于游戏中对象的坐标空间，由游戏中对象的某点为原点与其自身质点所构成的坐标系，通常是笛卡尔坐标系。\n* 观察空间：又称摄像机空间，是固定在摄像机的坐标系，他的原点置于摄像机的焦点。\n\n### 基的变更\n上面描述的三者空间可以互相转化，即模型空间与观察空间可以转化为世界空间。这样当玩家角色与物体接触的时候通过基于同一个坐标系的数据进行判断是否产生碰撞。三个坐标构成层次关系，其中世界坐标是最底层的父坐标。\n\n把点或者矢量从坐标系**C**转移到坐标系**P**写作**M**ᴄ→ᴘ,设点在坐标系C中的点坐标为**P**ᴄ,在坐标系**P**中的坐标是**P**ᴘ。则他们的转化公式如下：\n<img src=\"/img/202012/037.png\" width=\"50%\" height=\"50%\">\n其中：\n* **i**ᴄ为子空间x轴的单位基矢量，这个矢量用父空间坐标表示\n* **j**ᴄ为子空间y轴的单位基矢量，这个矢量用父空间坐标表示\n* **k**ᴄ为子空间z轴的单位基矢量，这个矢量用父空间坐标表示\n* **t**ᴄ为子坐标系相对于父坐标系的平移\n\n例子如下：\n假设子空间绕z轴旋转角度ᵞ，没有平移，得到公式如下：\n<img src=\"/img/202012/038.png\" width=\"50%\" height=\"50%\">\n旋转示例如下：\n<img src=\"/img/202012/039.png\" width=\"50%\" height=\"50%\">\n\n在坐标空间的变换过程中有两种选择：变换坐标系或者变换矢量：\n<img src=\"/img/202012/040.png\" width=\"50%\" height=\"50%\">\n具体选择哪一种要看情况而定。\n\n## 四元数\n3 × 3矩阵并不是最理想的旋转表达形式，原因如下：\n1. 3 × 3矩阵有9个浮点数来旋转矢量，但实际上旋转只有三个自由度（偏航角、俯仰角、滚动角）\n2. 用矢量矩阵乘法来旋转矢量需要3个点积运算。\n3. 在计算机图形学中，表示两个矢量位置的变换通常需要顺滑的过度，因此需要计算两个位置中间的值，这用矩阵计算很麻烦。即不能完全实现游戏对象的变换。\n\n因此采用四元数来表示旋转，定义如下：\n> 单位长度的四元数能代表三维旋转\n\n即四元数中四个标量的平方和等于1的情况下都能表示三维旋转。\n\n### 单位四元数视为三维旋转\n四元数中有四个标量。\n<img src=\"/img/202012/042.png\" width=\"50%\" height=\"50%\">\n前三个标量组成的矢量**v**是旋转的单位轴乘以旋转半角的正弦。第四个标量qs是旋转半角的余弦。可以写成:\n<img src=\"/img/202012/041.png\" width=\"50%\" height=\"50%\">\n其中**a**为旋转轴方向的单位矢量，θ是旋转角度。旋转的方向遵守右手守则。从上面可以得到以下等式：\n<img src=\"/img/202012/043.png\" width=\"50%\" height=\"50%\">\n\n### 四元数运算\n\n#### 乘法\n乘法是四元数最常用的计算方法之一，给定两个四元数q和p，他们分别代表旋转**Q**和**P**，则qp代表两个旋转的合成旋转，即先旋转**Q**再旋转**P**。这种跟旋转相关的四元数乘法又叫做格拉斯曼积，定义的pq乘积如下：\n<img src=\"/img/202012/044.png\" width=\"50%\" height=\"50%\">\n结果分成矢量部分和标量部分，其中矢量部分的结果为四元数的x、y、z，标量部分是四元数的w。\n\n#### 共轭以及逆四元数\n四元素q的逆四元数写作q⁻¹,逆四元数和原四元数的乘积等于1.即qq⁻¹=（0**i** + 0**j** + 0**k** + 1）= 1.所以四元数[0 0 0 1]代表零旋转。\n\n四元数q的共轭写作qº（这里的º应该是*，我打不出来。）定义如下：\n<img src=\"/img/202012/045.png\" width=\"50%\" height=\"50%\">\n从公式中可以知道共轭是四元数矢量部分求反，但保持标量部分不变，有了这个定义，逆四元数又可以写成：\n<img src=\"/img/202012/046.png\" width=\"50%\" height=\"50%\">\n由于我们用于旋转的四元数都是单位长度，因此分母为1，化简如下：\n<img src=\"/img/202012/047.png\" width=\"50%\" height=\"50%\">\n所以四元数的逆四元数等于四元数的共轭，但是求共轭的速度快于求逆。因此通常可以用共轭代替求逆的步骤。同时这也比计算3 × 3的逆矩阵快，所以这一步可以用作性能的优化。\n\n多个四元数之积的逆四元数等于相反的逆四元数相乘，共轭同理。\n<img src=\"/img/202012/048.png\" width=\"50%\" height=\"50%\">\n\n### 用四元数旋转矢量\n用四元数旋转矢量，首先要把矢量转化为四元数形式。由于四元数比矢量多了一个标量，只要将第四个标量设置为0即可。给定矢量**v**,他的四元数形式表示为**v**ᶥ=[**v** 0]=[x y z 0]。\n\n要用四元数q旋转矢量**v**，需要先用q乘以**v**然后再乘以q的逆四元数。\n<img src=\"/img/202012/049.png\" width=\"50%\" height=\"50%\">\n因为旋转的四元数都是单位四元数，所以可以用四元数的共轭代替逆四元数：\n<img src=\"/img/202012/050.png\" width=\"50%\" height=\"50%\">\n\n> 在游戏中，各个模型空间相对于世界空间就可以用四元数表示，当要将模型空间内的坐标转化为世界空间的坐标时，只需要将其乘以模型空间定量的四元数即可\n\n#### 四元数的串接\n从上面的四元数用于矢量可以知道，四元数的串接类似于一层一层包裹矢量：\n<img src=\"/img/202012/051.png\" width=\"50%\" height=\"50%\">\n\n### 等价的四元数和矩阵\n任何三维旋转都可以从3 × 3矩阵表达方式和四元数表达方式之间自由变换。设q=[q**v** qs] = [x y z w]，则转化为矩阵表达**R**如下：\n<img src=\"/img/202012/052.png\" width=\"50%\" height=\"50%\">\n类似的，**R**也可以通过特定的计算得到四元数。下面是一段C/C++代码用于将矩阵转化为四元数:\n\n```C++\n#include \"math.h\"\n#include \"iostream\"\n\nvoid rotMatrixToQuternion(const float R[3][3], float q[4])\n{\n    float trace = R[0][0] + R[1][1] + R[2][2];\n    \n    //检测主轴\n    if (trace > 0.0f) {\n        float s = sqrt(trace + 1.0f);\n        q[3] = s * 0.5f;\n\n        float t = 0.5f / s;\n        q[0] = (R[2][1] - R[1][2]) * t;\n        q[1] = (R[0][2] - R[2][0]) * t;\n        q[2] = (R[1][0] - R[0][1]) * t;\n    } else {\n        //主轴为负\n        int i = 0;\n        if (R[1][1] > R[0][0]) i = 1;\n        if (R[2][2] > R[i][i]) i = 2;\n\n        static const int next[3] = {1, 2, 0};\n        int j = next[i];\n        int k = next[j];\n\n        float s = sqrt((R[i][i] - (R[j][j] + R[k][k])) + 1.0f);\n        q[i] = s * 0.5f;\n\n        float t;\n        if (s != 0.0f)  t = 0.5f / s;\n        else            t = s;\n\n        q[3] = (R[k][j] - R[j][k]) * t;\n        q[j] = (R[j][i] + R[i][j]) * t;\n        q[k] = (R[k][i] + R[i][k]) * t;\n    }\n}\n```\n\n### 旋转性的线性插值\n在两个旋转中间，为了保证物体变换表现的顺滑，需要获取到物体在变换时处于两个旋转中间的位置，这个点就叫做插值。\n\n虽然两个旋转矩阵之间也可以做插值，但是他们的计算开销远远大于四元数。\n\n最简单快捷的插值方法就是套用四维矢量的线性插值（LERP）至四元数。给定两个代表旋转A、B的四元数qᴀ、qʙ，可以找出旋转A到旋转B之间β百分点的中间旋转qʟᴇʀᴘ:\n<img src=\"/img/202012/053.png\" width=\"50%\" height=\"50%\">\n> 插值后的四元数需要再次归一，因为插值计算无法保证矢量长度。\n\n在图像中体现如下：\n<img src=\"/img/202012/054.png\" width=\"50%\" height=\"50%\">\n\n#### 球体中的插值\nLERP计算的缺点在于没有考虑四元数其实是四维**超球**上的点。LERP其实是沿着球体的弦进行插值，这样会导致：当β以恒定速率改变时，旋转动画并不是以恒定速率变换的，旋转会在两端慢，在中间骤然加快。为了解决这个问题产生了一个新的插值：**球面线性插值**（SLERP）。SLERP使用正弦和余弦在四维超球面的大圆上进行插值，而不是沿着弦上插值，这样，当β以恒定速率改变时，插值结果会以常速角速度变化。两者的区别如下：\n<img src=\"/img/202012/055.png\" width=\"50%\" height=\"50%\">\n\nSLERP公式如下：\n<img src=\"/img/202012/056.png\" width=\"50%\" height=\"50%\">\n其中wᴘ和wǫ取代（1-β）和β，这两个参数使用到了两个四元数之间的正弦与余弦夹角。\n<img src=\"/img/202012/057.png\" width=\"50%\" height=\"50%\">\n\n虽然SLERP比LERP更加完善，但同时计算插值的开销也更大，具体使用那种插值计算需要根据实际情况来看，在游戏中，优化也占很重要的一部分。\n\n## 各种旋转\n### 欧拉角\n欧拉角能表示旋转，由三个标量组成（偏航角、俯视角、滚动角）。\n\n优点：\n* 小巧，只由3个浮点数组成\n* 直观，容易把三个数值视觉化\n* 对围绕单轴的旋转容易插值\n\n缺点：\n* 对任意方向的旋转不方便插值\n* 会遭遇万向节死锁\n* 旋转次序影响最终结果\n* 依赖数据多，需要有x/y/z轴和前/左右/上方向上的映射\n\n### 3 x 3矩阵\n优点：\n* 不受万向节锁的影响，独一无二地表达任意旋转\n* 旋转可以通过矩阵乘法直接施加在矢量或点上\n* 市面上大多数CPU或GPU都针对矩阵乘法做了内建支持\n* 纯旋转的逆矩阵为转置矩阵，求解方便\n\n缺点：\n* 不直观，看见一个大数字表无法直观的将其想象在三维空间的变换\n* 不容易插值，计算繁琐\n* 占用空间大，需要占用9个存储空间\n\n### 轴角\n通过一个单位矢量定义旋转轴，一个标量定义旋转角表示旋转。类似于四元数表示法[旋转轴 旋转角]，写成[**a** θ]的形式。其中**a**是旋转轴、θ是旋转角。\n\n优点：\n* 表现直观，直接存在旋转轴与旋转角\n* 紧凑，只占用4个存储空间\n\n缺点：\n* 无法进行简单的插值\n* 轴角形式无法直接施加于点或矢量，需要将其先转化为四元数\n\n### 四元数\n与轴角的区别：旋转轴矢量长度为旋转半角的正弦，第四个分量是旋转半角的余弦。\n\n优点：\n* 四元数乘法能串接旋转，并把旋转直接施加于矢量和点\n* 可以轻易地用LERP和SLERP进行旋转插值\n* 存储空间小，只需要4个浮点数的存储空间\n\n### SQT变换\n4 x 4表示任意变换（旋转、平移、缩放），但是占用空间大，因此，将四元数加上平移矢量与缩放因子来实现任意仿射变换。他的体积比4 x 4矩阵小。统一缩放只需要8个存储空间，非统一缩放需要10个存储空间。\n> 因为统一缩放的时候缩放因子是一个标量，而非统一缩放的时候缩放因子是由三个标量组成的矢量\n\n优点：\n* 可以表示任意仿射变换\n* 空间比4 x 4矩阵小\n* 容易插值，各个部分可以采用不同的插值算法，平移矢量可以用LERP、四元数则可以矢量LERP或SLERP。\n\n### 其他\n其他还有**对偶四元数**、**旋转和自由度**等方式。\n\n","tags":["数学"]},{"title":"【剑指 offer】15.二进制中1的个数","url":"/2020/11/30/【剑指-offer】15-二进制中1的个数/","content":"来源：力扣（LeetCode）\n\n链接：https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof\n\n### 题目描述\n请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。\n\n示例 1：\n```bash\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n```\n\n示例 2：\n```bash\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n```\n\n示例 3：\n```bash\n输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n```\n\n提示：\n* 输入必须是长度为 32 的 二进制串 。\n\n### 我的解题\n#### 思路\n通过逐位比较来确定给定数字中出现的1的个数，这里我一开始使用了取模，实际上还有更快的位运算，不过这里有个小坑，即题目中给定的int需要看成无符号位，即当int为负数的时候最高位是1。因此需要在Java中通过>>>来达成数字的无符号移动。\n\n#### 结果\n```java\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int size = 0;\n        while (n != 0) {\n            size += (n & 1);\n            n >>>= 1;\n        }\n        return size;\n    }\n}\n```\n### 最优解\n#### 思路\n有两种方法，一种就是上面的通过每一位的比较来得到数字中1的个数，但是还有一个更快的方法，即通过n&(n-1)这样的位运算。n-1在二进制中表示将n的最低位的1修改成0。与上面方法的区别就是，逐位计算循环次数固定是数字的位数，这种方法的循环次数则是数字中1的个数。设上一种方法的时间复杂度为O(N)、这种时间复杂度为O(M)，则N >= M.\n<img src=\"https://pic.leetcode-cn.com/9bc8ab7ba242888d5291770d35ef749ae76ee2f1a51d31d729324755fc4b1b1c-Picture10.png\" width=\"50%\" height=\"50%\">\n\n#### 解法\n```java\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int size = 0;\n        while (n != 0) {\n            size += 1;\n            n = n & (n - 1);\n        }\n        return size;\n    }\n}\n```","tags":["算法"]},{"title":"【剑指 offer】14- II. 剪绳子 II","url":"/2020/11/18/【剑指-offer】14-II-剪绳子-II/","content":"来源：力扣（LeetCode）\n\n链接：https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof\n### 题目描述\n给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n示例 1：\n```bash\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1\n```\n示例 2:\n```bash\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36\n```\n\n提示：**2 <= n <= 1000**\n\n### 我的解题\n#### 思路\n这题根昨天的题目几乎一样，不过要注意的一点就是由于多了一个取模的条件，所以直接通过dp的max比较已经不行了。但是思路还是一样的。根据数学公式得出，数字n按照拆分的优先级分别是3、2、1，因此我们可以通过循环一个一个减去对应的数字然后保留计算结果，要注意的是，当结果已经小于等于4的时候需要特殊对待。\n* n = 4：直接结果与4相乘并退出循环呢\n* n < 3：结果与n相乘并退出循环\n\n#### 结果\n```java\nclass Solution {\n    public int cuttingRope(int n) {\n        if (n <= 3) {\n            return n - 1;\n        } else if (n == 4) {\n            return n;\n        }\n\n        int p = 1000000007;\n        long ans = 1L;\n        int a = 3;\n        while (n > 0) {\n            ans *= a;\n            ans %= p;\n            n -= 3;\n            if (n == 4 || n < 3) {\n                a = n;\n            }\n        }\n        return (int) ans;\n    }\n}\n```\n\n### 最优解\n#### 思路\n数学的推导过程与上一题一样，但是在最后需要考虑**大数求余**的问题。针对这个问题主要有两种解决思路：\n1. 循环求余\n2. 快速冥求余\n\n两种方法都是根据以下求余循环法则推导而成：\n> (xy)%p = (x%p)(y%p)%p\n\n##### 1.循环求余\n根据上述公式推导得：<br>\n<img src=\"/img/202011/009.png\" width=\"50%\" height=\"50%\"><br>\n我们可以通过寻汗操作n1、n2...na对p的余数，保证每轮的中间值都在int32的范围内。\n\n```python\n# 求 (x^a) % p —— 循环求余法\ndef remainder(x, a, p):\n    rem = 1\n    for _ in range(a):\n        rem = (rem * x) % p\n    return rem\n```\n##### 2.快速冥求余\n根据求余公式推导出：<br>\n<img src=\"/img/202011/010.png\" width=\"50%\" height=\"50%\"><br>\n当a为奇数时，a/2不是整数，因此将其分为两种情况（“//”表示向下取整的除法）\n<img src=\"/img/202011/011.png\" width=\"50%\" height=\"50%\"><br>\n利用以上公式，可通过循环操作每次把指数 aa 问题降低至指数 a//2 问题，只需循环 log_2(N) 次，因此可将复杂度降低至对数级别。封装方法代码如下所示。\n\n```python\n# 求 (x^a) % p —— 快速幂求余\ndef remainder(x, a, p):\n    rem = 1\n    while a > 0:\n        if a % 2: rem = (rem * x) % p\n        x = x ** 2 % p\n        a //= 2\n    return rem\n```\n\n#### 结果\n```java\nclass Solution {\n    public int cuttingRope(int n) {\n        if(n <= 3) return n - 1;\n        int b = n % 3, p = 1000000007;\n        long rem = 1, x = 3;\n        for(int a = n / 3 - 1; a > 0; a /= 2) {\n            if(a % 2 == 1) rem = (rem * x) % p;\n            x = (x * x) % p;\n        }\n        if(b == 0) return (int)(rem * 3 % p);\n        if(b == 1) return (int)(rem * 4 % p);\n        return (int)(rem * 6 % p);\n    }\n}\n```","tags":["算法"]},{"title":"【剑指 offer】14- I. 剪绳子","url":"/2020/11/17/【剑指-offer】14-I-剪绳子/","content":"来源：力扣（LeetCode）<br>\n链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof\n### 题目描述\n给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]\\*k[1]\\*...\\*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n\n示例 1：\n\n```bash\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1\n```\n\n示例 2:\n```bash\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36\n```\n提示：\n> 2 <= n <= 58\n\n### 我的解题\n#### 思路\n第一眼就认为用动态规划求解：设将n长的绳子分成m份后每份的乘积为f(n, m)，且 1 < m <= n,但这样就很难得到状态转移方程，因此思路不通。\n\n后来用f(n)表示将n份绳子分成至少2份后各个结果最大的积。则f(0) = 0, f(1) = 1;后面我自己想状态转移方程就想不到了。所以还是直接看的答案。\n\n### 最优解\n#### 思路\n\n##### 动态规划\n对于的正整数 n，当 n≥2 时，可以拆分成至少两个正整数的和。令 k 是拆分出的第一个正整数，则剩下的部分是 n−k，n−k 可以不继续拆分，或者继续拆分成至少两个正整数的和。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。\n\n* **dp数组的含义**： dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积。\n* **边界条件**： 0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0]=dp[1]=0。\n* **状态转移方程**：当 i≥2 时，假设对正整数 i 拆分出的第一个正整数是 j（1≤j<i），则有以下两种方案：\n    * 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j×(i−j)；\n    * 将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j×dp[i−j]。\n\n因此，当 j 固定时，有 dp[i]=max(j×(i−j),j×dp[i−j])。由于 j 的取值范围是 1 到 i−1，需要遍历所有的 j 得到 dp[i] 的最大值，因此可以得到状态转移方程如下：<br>\n<img src=\"/img/202011/002.png\" width=\"50%\" height=\"50%\">\n\n##### 数学思想\n设将长度为 n 的绳子切为 a 段：<br>\n<img src=\"/img/202011/003.png\" width=\"50%\" height=\"50%\">\n\n本题等价于求解：<br>\n<img src=\"/img/202011/004.png\" width=\"50%\" height=\"50%\">\n\n以下公式为“算术几何均值不等式” ，等号当且仅当 n1 = n2 = ... = na 时候成立：<br>\n<img src=\"/img/202011/005.png\" width=\"50%\" height=\"50%\">\n\n> 推论一： 将绳子 以相等的长度等分为多段 ，得到的乘积最大。\n\n<img src=\"/img/202011/006.png\" width=\"70%\" height=\"70%\">\n<img src=\"/img/202011/007.png\" width=\"70%\" height=\"70%\">\n<img src=\"/img/202011/008.png\" width=\"50%\" height=\"50%\">\n\n#### 结果\n\n##### 动态规划\n```java\nclass Solution {\n    public int cuttingRope(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            for (int j = 1; j < i; j++) {\n                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));\n            }\n        }\n        return dp[n];\n    }\n}\n```\n\n##### 数学思想\n```java\nclass Solution {\n    public int cuttingRope(int n) {\n        if (n <= 3) {\n            return n - 1;\n        }\n        int a = n / 3;\n        int b = n % 3;\n        if (b == 0) {\n            return (int) Math.pow(3, a);\n        }\n        if (b == 1) {\n            return (int) Math.pow(3, a - 1) * 4;\n        }\n        return (int) Math.pow(3, a) * 2;\n    }\n}\n```","tags":["算法"]},{"title":"【剑指 offer】13. 机器人的运动范围","url":"/2020/11/16/【剑指-offer】13-机器人的运动范围/","content":"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof\n### 题目描述\n地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n\n示例 1：\n\n```bash\n输入：m = 2, n = 3, k = 1\n输出：3\n```\n\n示例 2：\n```bash\n输入：m = 3, n = 1, k = 0\n输出：1\n```\n\n提示：\n\n> 1 <= n,m <= 100\n> 0 <= k <= 20\n\n### 我的解题\n#### 思路\n题目中给了一个限定条件*不能进入行坐标和列坐标的数位之和大于k的格子*，即从点（0，0）出发的机器人在这个条件内能都达到的所有方块数量，同时要注意，所有能够到达的方块都是和点（0，0）连续的，例如当k=2时候，点（100，100），光看k的值是满足的但是机器人无法到达这个点。\n\n这种涉及到连续路径查询，且只需要查询个数不需要查询具体某条路线的问题可以用广度优先搜索来完成。\n\n#### 结果\n```java\nclass Solution {\n    public int movingCount(int m, int n, int k) {\n        //广度优先搜索\n        Queue<int[]> queue = new LinkedList<>();\n        Set<String> used = new HashSet<>();\n        used.add(\"0,0\");\n        queue.add(new int[] {0, 0});\n        int[][] foots = {\n            {1, 0},\n            {-1, 0},\n            {0, 1},\n            {0, -1}\n        };\n        int count = 0;\n\n        while (!queue.isEmpty()) {\n            int[] num = queue.poll();\n            int mK = getK(num[0], num[1]);\n            if (mK > k) {\n                continue;\n            }\n\n            for (int[] foot : foots) {\n                int x = foot[0] + num[0];\n                int y = foot[1] + num[1];\n                if (x < 0 || y < 0 || x >= m || y >= n) {\n                    continue;\n                }\n                String key = x + \",\" + y;\n                if (used.contains(key)) {\n                    continue;\n                }\n                used.add(key);\n\n                if (getK(x, y) > k) {\n                    continue;\n                }\n                queue.add(new int[] {x, y});\n            }\n\n            count++;\n        }\n        return count;\n    }\n\n    private int getK(int i, int j) {\n        int sum = 0;\n        while (i > 0) {\n            int n = i % 10;\n            sum += n;\n            i /= 10;\n        }\n        while (j > 0) {\n            int n = j % 10;\n            sum += n;\n            j /= 10;\n        }\n        return sum;\n    }\n\n}\n```\n### 最优解\n#### 思路\n\n##### 思路一：广度优先搜索\n不过在\n```java\nint[][] foots = {\n    {1, 0},\n    {-1, 0},\n    {0, 1},\n    {0, -1}\n};\n```\n这一步可以用\n```java\nint[][] foots = {\n    {1, 0},\n    {0, 1}\n};\n```\n来替代，用于减少循环次数，因为机器人只会往右或下行走。\n\n##### 思路二：递推\n考虑到方法一提到搜索的方向只需要朝下或朝右，我们可以得出一种递推的求解方法。\n定义 vis[i][j] 为 (i, j) 坐标是否可达，如果可达返回 1，否则返回 0。\n首先 (i, j) 本身需要可以进入，因此需要先判断 i 和 j 的数位之和是否大于 k ，如果大于的话直接设置 vis[i][j] 为不可达即可。\n否则，前面提到搜索方向只需朝下或朝右，因此 (i, j) 的格子只会从 (i - 1, j) 或者 (i, j - 1) 两个格子走过来（不考虑边界条件），那么 vis[i][j] 是否可达的状态则可由如下公式计算得到：<br>\n> **vis[i][j]=vis[i−1][j] or vis[i][j−1]**\n\n即只要有一个格子可达，那么 (i, j) 这个格子就是可达的，因此我们只要遍历所有格子，递推计算出它们是否可达然后用变量 ans 记录可达的格子数量即可。\n初始条件 vis[i][j] = 1 ，递推计算的过程中注意边界的处理。\n\n#### 结果\n```java\nclass Solution {\n    public int movingCount(int m, int n, int k) {\n        if (k == 0) {\n            return 1;\n        }\n        boolean[][] vis = new boolean[m][n];\n        int ans = 1;\n        vis[0][0] = true;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if ((i == 0 && j == 0) || get(i) + get(j) > k) {\n                    continue;\n                }\n                // 边界判断\n                if (i - 1 >= 0) {\n                    vis[i][j] |= vis[i - 1][j];\n                }\n                if (j - 1 >= 0) {\n                    vis[i][j] |= vis[i][j - 1];\n                }\n                ans += vis[i][j] ? 1 : 0;\n            }\n        }\n        return ans;\n    }\n\n    private int get(int x) {\n        int res = 0;\n        while (x != 0) {\n            res += x % 10;\n            x /= 10;\n        }\n        return res;\n    }\n}\n```","tags":["算法"]},{"title":"【剑指 offer】12. 矩阵中的路径","url":"/2020/11/15/【剑指-offer】12-矩阵中的路径/","content":"链接：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n### 题目描述\n请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。\n\n```bash\n[[\"a\",\"b\",\"c\",\"e\"],\n[\"s\",\"f\",\"c\",\"s\"],\n[\"a\",\"d\",\"e\",\"e\"]]\n```\n\n但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。\n\n \n\n示例 1：\n\n```bash\n输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n输出：true\n```\n\n\n示例 2：\n```bash\n输入：board = [[\"a\",\"b\"],[\"c\",\"d\"]], word = \"abcd\"\n输出：false\n```\n\n提示：\n```bash\n1 <= board.length <= 200\n1 <= board[i].length <= 200\n```\n\n### 我的解题\n#### 思路\n首先想到的就是深度优先搜索，即遍历board，判断下标元素是否和word的首字符一致，如果一致则判断周围四个格子是否有字符与word的下一个字符一致。为了避免循环判断，采用一个数据结构记录已经走过的路程。\n\n#### 结果\n```java\n\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        char[] words = word.toCharArray();\n        int[][] used = new int[board.length][board[0].length];\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if (board[i][j] != words[0]) {\n                    continue;\n                }\n                if (check(board, i, j, words, 0, used)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean check(char[][] board, int i, int j, char[] words, int wordIndex, int[][] used) {\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) {\n            if (wordIndex >= words.length) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n        if (used[i][j] == 1) {\n            return false;\n        }\n        if (wordIndex >= words.length) {\n            return true;\n        }\n        if (board[i][j] != words[wordIndex]) {\n            return false;\n        }\n        used[i][j] = 1;\n        int[][] foots = {\n            {1, 0},\n            {-1, 0},\n            {0, 1},\n            {0, -1}\n        };\n        for (int[] foot : foots) {\n            int x = i + foot[0];\n            int y = j + foot[1];\n            if (check(board, x, y, words, wordIndex + 1, used)) {\n                return true;\n            }\n        }\n        used[i][j] = 0;\n        return false;\n    }\n}\n```\n### 最优解\n#### 思路\n本问题是典型的矩阵搜索问题，可使用 深度优先搜索（DFS）+ 剪枝 解决。\n\n* **深度优先搜索**： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。\n* **剪枝**： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。\n<!-- ![]() -->\n<img src=\"/img/202011/001.png\" width=\"50%\" height=\"50%\">\n\n##### DFS 解析：\n\n* **递归参数**： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。\n* **终止条件**：\n    1. 返回 falsefalse ： (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。\n    2. 返回 truetrue ： k = len(word) - 1 ，即字符串 word 已全部匹配。\n* **递推工作**：\n    1. 标记当前矩阵元素： 将 board[i][j] 修改为 空字符 '' ，代表此元素已访问过，防止之后搜索时重复访问。\n    2. 搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。\n    3. 还原当前矩阵元素： 将 board[i][j] 元素还原至初始值，即 word[k] 。\n* **返回值**： 返回布尔量 res ，代表是否搜索到目标字符串。\n\n> 使用空字符（Python: '' , Java/C++: '\\0' ）做标记是为了防止标记字符与矩阵原有字符重复。当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误。\n\n##### 复杂度分析：\n> M,N 分别为矩阵行列大小， K 为字符串 word 长度。\n\n* 时间复杂度 O(3^K * MN) : 最差情况下，需要遍历矩阵中长度为 KK 字符串的所有方案，时间复杂度为O(3^K).矩阵中共有 MN 个起点，时间复杂度为 O(MN) 。\n    * 方案数计算设字符串长度为 KK ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为O(3^K) 。\n* 空间复杂度 O(K) ： 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K = K=MN ，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。\n\n#### 结果\n```java\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        char[] words = word.toCharArray();\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board[0].length; j++) {\n                if(dfs(board, words, i, j, 0)) return true;\n            }\n        }\n        return false;\n    }\n    boolean dfs(char[][] board, char[] word, int i, int j, int k) {\n        if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]) return false;\n        if(k == word.length - 1) return true;\n        board[i][j] = '\\0';\n        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || \n                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);\n        board[i][j] = word[k];\n        return res;\n    }\n}\n```","tags":["算法"]},{"title":"【剑指 offer】07. 重建二叉树","url":"/2020/11/11/【剑指-offer】07-重建二叉树/","content":"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof\n### 题目描述\n输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n\n例如，给出\n\n> 前序遍历 preorder = [3,9,20,15,7]\n> 中序遍历 inorder = [9,3,15,20,7]\n返回如下的二叉树：\n\n```bash\n   3\n  / \\ \n 9  20 \n   /  \\ \n  15   7 \n```\n\n限制：\n\n> 0 <= 节点个数 <= 5000\n\n### 我的解题\n#### 思路\n首先确定两种遍历方式的区别：\n* 前序遍历：根节点->左节点->右节点\n* 中序遍历：左节点->根节点->右节点\n\n因此，在中序遍历中，在根节点之前被访问的节点都位于左子树，在根节点之后被访问的节点都位于右子树。同时前序遍历的数据顺序对于跟节点来说，等于如下结构【根节点】【所有左节点】【所有右节点】，因此，在通过跟节点从中序遍历中得到跟节点的左右字节点队列与个数后，能根据左右字节点的数量从前序遍历中分解出左节点队列和右节点队列，到了这步通过迭代即可遍历树。\n\n> 其实我只到两种遍历的区别，没有第一时间意识到通过宏观的角度将数组分成左右两个节点的队列，太久没有接触树的概念生疏了。\n\n#### 结果\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if (preorder == null || preorder.length == 0) {\n            return null;\n        }\n        Map<Integer, Integer> indexMap = new HashMap<Integer, Integer>();\n        int length = preorder.length;\n        for (int i = 0; i < length; i++) {\n            indexMap.put(inorder[i], i);\n        }\n        TreeNode root = buildTree(preorder, 0, length - 1, inorder, 0, length - 1, indexMap);\n        return root;\n    }\n\n    public TreeNode buildTree(int[] preorder, int preorderStart, int preorderEnd, int[] inorder, int inorderStart, int inorderEnd, Map<Integer, Integer> indexMap) {\n        if (preorderStart > preorderEnd) {\n            return null;\n        }\n        int rootVal = preorder[preorderStart];\n        TreeNode root = new TreeNode(rootVal);\n        if (preorderStart == preorderEnd) {\n            return root;\n        } else {\n            int rootIndex = indexMap.get(rootVal);\n            int leftNodes = rootIndex - inorderStart, rightNodes = inorderEnd - rootIndex;\n            TreeNode leftSubtree = buildTree(preorder, preorderStart + 1, preorderStart + leftNodes, inorder, inorderStart, rootIndex - 1, indexMap);\n            TreeNode rightSubtree = buildTree(preorder, preorderEnd - rightNodes + 1, preorderEnd, inorder, rootIndex + 1, inorderEnd, indexMap);\n            root.left = leftSubtree;\n            root.right = rightSubtree;\n            return root;\n        }\n    }\n}\n```\n ### 最优解\n #### 思路\n 第一个通过迭代的思路同上。因此这里介绍另一种方法：*迭代*。\n 例如要重建的是如下二叉树。\n\n```bash\n        3\n       / \\\n      9  20\n     /  /  \\\n    8  15   7\n   / \\\n  5  10\n /\n4\n```\n\n其前序遍历和中序遍历如下。\n\n>preorder = [3,9,8,5,4,10,20,15,7]\n>inorder = [4,5,8,10,9,3,15,20,7]\n\n前序遍历的第一个元素 3 是根节点，第二个元素 9 可能位于左子树或者右子树，需要通过中序遍历判断。\n\n中序遍历的第一个元素是 4 ，不是根节点 3，说明 9 位于左子树，因为根节点不是中序遍历中的第一个节点。同理，前序遍历的后几个元素 8、5、4 也都位于左子树，且每个节点都是其上一个节点的左子节点。\n\n前序遍历到元素 4，和中序遍历的第一个元素相等，说明前序遍历的下一个元素 10 位于右子树。那么 10 位于哪个元素的右子树？从前序遍历看，10 可能位于 4、5、8、9、3 这些元素中任何一个元素的右子树。从中序遍历看，10 在 8 的后面，因此 10 位于 8 的右子树。把前序遍历的顺序反转，则在 10 之前的元素是 4、5、8、9、3，其中 8 是最后一次相等的节点，因此前序遍历的下一个元素位于中序遍历中最后一次相等的节点的右子树。\n\n根据上述例子和分析，可以使用栈保存遍历过的节点。初始时令中序遍历的指针指向第一个元素，遍历前序遍历的数组，如果前序遍历的元素不等于中序遍历的指针指向的元素，则前序遍历的元素为上一个节点的左子节点。如果前序遍历的元素等于中序遍历的指针指向的元素，则正向遍历中序遍历的元素同时反向遍历前序遍历的元素，找到最后一次相等的元素，将前序遍历的下一个节点作为最后一次相等的元素的右子节点。其中，反向遍历前序遍历的元素可通过栈的弹出元素实现。\n\n* 使用前序遍历的第一个元素创建根节点。\n* 创建一个栈，将根节点压入栈内。\n* 初始化中序遍历下标为 0。\n* 遍历前序遍历的每个元素，判断其上一个元素（即栈顶元素）是否等于中序遍历下标指向的元素。\n    * 若上一个元素不等于中序遍历下标指向的元素，则将当前元素作为其上一个元素的左子节点，并将当前元素压入栈内。\n    * 若上一个元素等于中序遍历下标指向的元素，则从栈内弹出一个元素，同时令中序遍历下标指向下一个元素，之后继续判断栈顶元素是否等于中序遍历下标指向的元素，若相等则重复该操作，直至栈为空或者元素不相等。然后令当前元素为最后一个想等元素的右节点。\n* 遍历结束，返回根节点。\n\n#### 结果\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if (preorder == null || preorder.length == 0) {\n            return null;\n        }\n        TreeNode root = new TreeNode(preorder[0]);\n        int length = preorder.length;\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        stack.push(root);\n        int inorderIndex = 0;\n        for (int i = 1; i < length; i++) {\n            int preorderVal = preorder[i];\n            TreeNode node = stack.peek();\n            if (node.val != inorder[inorderIndex]) {\n                node.left = new TreeNode(preorderVal);\n                stack.push(node.left);\n            } else {\n                while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {\n                    node = stack.pop();\n                    inorderIndex++;\n                }\n                node.right = new TreeNode(preorderVal);\n                stack.push(node.right);\n            }\n        }\n        return root;\n    }\n}\n```","tags":["算法"]},{"title":"【剑指-offer】05.替换空格","url":"/2020/11/09/【剑指-offer】05-替换空格/","content":"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof\n### 题目描述\n请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。\n\n示例 1：\n\n> 输入：s = \"We are happy.\"\n> 输出：\"We%20are%20happy.\"\n\n限制：\n> 0 <= s 的长度 <= 10000\n\n### 我的解题\n#### 思路\n有两种方法：\n1. 调用replace库函数直接替换\n2. 遍历字符串，用if判断字符是否是空格，如果是则替换\n\n#### 结果\n我这里使用方法2\n```java\nclass Solution {\n    public String replaceSpace(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (c == ' ') {\n                sb.append(\"%20\");\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n ### 最优解\n #### 思路\n 如果想把这道题目做到极致，就不要只用额外的辅助空间了！\n当然这只是针对C++的情况下，因为在C++中，字符数组是可以在原有的基础上扩充的。\n\n首先扩充数组到每个空格替换成\"%20\"之后的大小。然后从后向前替换空格，也就是双指针法。\n\n为什么不从前往后扩充呢？如果从前往后扩充的话时间复杂度就是O(n^2)了。因为每次添加元素都要将添加元素之后的所有元素向后移动。\n\n其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。这么做有两个好处：\n1. 不用申请新数组。\n2. 从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。\n\n#### 结果\n```C++\npublic:\n    string replaceSpace(string s) {\n        int count = 0; // 统计空格的个数\n        int sOldSize = s.size();\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == ' ') {\n                count++;\n            }\n        }\n        // 扩充字符串s的大小，也就是每个空格替换成\"%20\"之后的大小\n        s.resize(s.size() + count * 2);\n        int sNewSize = s.size();\n        // 从后先前将空格替换为\"%20\"\n        for (int i = sNewSize - 1, j = sOldSize - 1; j < i; i--, j--) {\n            if (s[j] != ' ') {\n                s[i] = s[j];\n            } else {\n                s[i] = '0';\n                s[i - 1] = '2';\n                s[i - 2] = '%';\n                i -= 2;\n            }\n        }\n        return s;\n    }\n};\n```","tags":["算法"]},{"title":"【剑指 offer】03.数组中重复的数字","url":"/2020/11/08/【剑指-offer】03-数组中重复的数字/","content":"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof\n### 题目描述\n找出数组中重复的数字。\n\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n示例 1：\n> 输入：\n> [2, 3, 1, 0, 2, 5, 3]\n> 输出：2 或 3 \n> 输入：\n> [2, 3, 1, 0, 2, 5, 3]\n> 输出：2 或 3 \n \n\n限制：\n\n> 2 <= n <= 100000\n\n### 我的解题\n#### 思路\n首先，其中的数字大小限定在0～n-1的范围内，既然给定了大小，那么直接创建对应长度的数组，即*int[] list = new int[nums.length]*，然后遍历数组nums，取出结果n,并将n作为下标在list数组中+1，如果结果大于1则表示当前n重复出现。\n\n这里其实就应用了空间换时间的策略，通过创建对应length的数组来加快取值过程，当然也可以使用哈希，那么我们就需要创建Set，为了加快速度，可以在创建对象的时候传入初始容量length。\n\n#### 结果\n```java\nclass Solution {\n    public int findRepeatNumber(int[] nums) {\n        int[] list = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            int n = nums[i];\n            list[n]++;\n            if (list[n] > 1) {\n                return n;\n            }\n        }\n        return -1;\n    }\n}\n```\n ### 最优解\n #### 思路\n 由于数字大小的范围是0～n-1，刚好数数组的下标对应，我们可以通过某些操作将值与下标对应，一旦某个索引的值不是一个，则找到了重复的数组，即发生了哈希碰撞。\n #### 结果\n```java\nclass Solution {\n    public int findRepeatNumber(int[] nums) {\n        //设索引初始值为 i = 0\n        int i = 0;\n        //遍历整个数组 nums \n        while(i < nums.length) {\n            //索引 i 的值为 i,无需执行交换操作，查看下一位\n            if(nums[i] == i) {\n                i++;\n                continue;\n            }\n            //索引 nums[i] 处的值也为 nums[i]，即找到一组相同值，返回 nums[i] 即可\n            if(nums[nums[i]] == nums[i]) return nums[i];\n            //执行交换操作，目的是为了使索引与值一一对应，即索引 0 的值为 0，索引 1 的值为 1\n            int tmp = nums[i];\n            nums[i] = nums[tmp];\n            nums[tmp] = tmp;\n        }\n        //如果遍历整个数组都没有找到相同的值，返回 -1\n        return -1;\n    }\n}\n```\n### 复杂度分析\n遍历数组需要O(n)的时间。\n\n在代码中的*continue*，这表示在while的一次循环中里只有这次循环将 索引(i) 与 索引值(num[i]) 匹配到了，才会执行下一次循环。\n\n在每一次的循环过程中，索引(i) 与 索引值(num[i]) 匹配到后，在后续的循环过程中不会操作它们，所以虽然一开始的循环过程中，执行的交换操作较多，但在后续的循环过程中根本不需要再执行操作了。\n\n根据均摊复杂度分析 ，总的时间复杂度为 O(N) ，N 为数组的长度。","tags":["算法"]}]