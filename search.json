[{"title":"【剑指 offer】15.二进制中1的个数","url":"/2020/11/30/【剑指-offer】15-二进制中1的个数/","content":"来源：力扣（LeetCode）\n\n链接：https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof\n\n### 题目描述\n请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。\n\n示例 1：\n```bash\n输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。\n```\n\n示例 2：\n```bash\n输入：00000000000000000000000010000000\n输出：1\n解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。\n```\n\n示例 3：\n```bash\n输入：11111111111111111111111111111101\n输出：31\n解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。\n```\n\n提示：\n* 输入必须是长度为 32 的 二进制串 。\n\n### 我的解题\n#### 思路\n通过逐位比较来确定给定数字中出现的1的个数，这里我一开始使用了取模，实际上还有更快的位运算，不过这里有个小坑，即题目中给定的int需要看成无符号位，即当int为负数的时候最高位是1。因此需要在Java中通过>>>来达成数字的无符号移动。\n\n#### 结果\n```java\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int size = 0;\n        while (n != 0) {\n            size += (n & 1);\n            n >>>= 1;\n        }\n        return size;\n    }\n}\n```\n### 最优解\n#### 思路\n有两种方法，一种就是上面的通过每一位的比较来得到数字中1的个数，但是还有一个更快的方法，即通过n&(n-1)这样的位运算。n-1在二进制中表示将n的最低位的1修改成0。与上面方法的区别就是，逐位计算循环次数固定是数字的位数，这种方法的循环次数则是数字中1的个数。设上一种方法的时间复杂度为O(N)、这种时间复杂度为O(M)，则N >= M.\n<img src=\"https://pic.leetcode-cn.com/9bc8ab7ba242888d5291770d35ef749ae76ee2f1a51d31d729324755fc4b1b1c-Picture10.png\" width=\"50%\" height=\"50%\">\n\n#### 解法\n```java\npublic class Solution {\n    // you need to treat n as an unsigned value\n    public int hammingWeight(int n) {\n        int size = 0;\n        while (n != 0) {\n            size += 1;\n            n = n & (n - 1);\n        }\n        return size;\n    }\n}\n```","tags":["算法"]},{"title":"【剑指 offer】14- II. 剪绳子 II","url":"/2020/11/18/【剑指-offer】14-II-剪绳子-II/","content":"来源：力扣（LeetCode）\n\n链接：https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof\n### 题目描述\n给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n示例 1：\n```bash\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1\n```\n示例 2:\n```bash\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36\n```\n\n提示：**2 <= n <= 1000**\n\n### 我的解题\n#### 思路\n这题根昨天的题目几乎一样，不过要注意的一点就是由于多了一个取模的条件，所以直接通过dp的max比较已经不行了。但是思路还是一样的。根据数学公式得出，数字n按照拆分的优先级分别是3、2、1，因此我们可以通过循环一个一个减去对应的数字然后保留计算结果，要注意的是，当结果已经小于等于4的时候需要特殊对待。\n* n = 4：直接结果与4相乘并退出循环呢\n* n < 3：结果与n相乘并退出循环\n\n#### 结果\n```java\nclass Solution {\n    public int cuttingRope(int n) {\n        if (n <= 3) {\n            return n - 1;\n        } else if (n == 4) {\n            return n;\n        }\n\n        int p = 1000000007;\n        long ans = 1L;\n        int a = 3;\n        while (n > 0) {\n            ans *= a;\n            ans %= p;\n            n -= 3;\n            if (n == 4 || n < 3) {\n                a = n;\n            }\n        }\n        return (int) ans;\n    }\n}\n```\n\n### 最优解\n#### 思路\n数学的推导过程与上一题一样，但是在最后需要考虑**大数求余**的问题。针对这个问题主要有两种解决思路：\n1. 循环求余\n2. 快速冥求余\n\n两种方法都是根据以下求余循环法则推导而成：\n> (xy)%p = (x%p)(y%p)%p\n\n##### 1.循环求余\n根据上述公式推导得：<br>\n<img src=\"/img/202011/009.png\" width=\"50%\" height=\"50%\"><br>\n我们可以通过寻汗操作n1、n2...na对p的余数，保证每轮的中间值都在int32的范围内。\n\n```python\n# 求 (x^a) % p —— 循环求余法\ndef remainder(x, a, p):\n    rem = 1\n    for _ in range(a):\n        rem = (rem * x) % p\n    return rem\n```\n##### 2.快速冥求余\n根据求余公式推导出：<br>\n<img src=\"/img/202011/010.png\" width=\"50%\" height=\"50%\"><br>\n当a为奇数时，a/2不是整数，因此将其分为两种情况（“//”表示向下取整的除法）\n<img src=\"/img/202011/011.png\" width=\"50%\" height=\"50%\"><br>\n利用以上公式，可通过循环操作每次把指数 aa 问题降低至指数 a//2 问题，只需循环 log_2(N) 次，因此可将复杂度降低至对数级别。封装方法代码如下所示。\n\n```python\n# 求 (x^a) % p —— 快速幂求余\ndef remainder(x, a, p):\n    rem = 1\n    while a > 0:\n        if a % 2: rem = (rem * x) % p\n        x = x ** 2 % p\n        a //= 2\n    return rem\n```\n\n#### 结果\n```java\nclass Solution {\n    public int cuttingRope(int n) {\n        if(n <= 3) return n - 1;\n        int b = n % 3, p = 1000000007;\n        long rem = 1, x = 3;\n        for(int a = n / 3 - 1; a > 0; a /= 2) {\n            if(a % 2 == 1) rem = (rem * x) % p;\n            x = (x * x) % p;\n        }\n        if(b == 0) return (int)(rem * 3 % p);\n        if(b == 1) return (int)(rem * 4 % p);\n        return (int)(rem * 6 % p);\n    }\n}\n```","tags":["算法"]},{"title":"【剑指 offer】14- I. 剪绳子","url":"/2020/11/17/【剑指-offer】14-I-剪绳子/","content":"来源：力扣（LeetCode）<br>\n链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof\n### 题目描述\n给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]\\*k[1]\\*...\\*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n\n示例 1：\n\n```bash\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1\n```\n\n示例 2:\n```bash\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36\n```\n提示：\n> 2 <= n <= 58\n\n### 我的解题\n#### 思路\n第一眼就认为用动态规划求解：设将n长的绳子分成m份后每份的乘积为f(n, m)，且 1 < m <= n,但这样就很难得到状态转移方程，因此思路不通。\n\n后来用f(n)表示将n份绳子分成至少2份后各个结果最大的积。则f(0) = 0, f(1) = 1;后面我自己想状态转移方程就想不到了。所以还是直接看的答案。\n\n### 最优解\n#### 思路\n\n##### 动态规划\n对于的正整数 n，当 n≥2 时，可以拆分成至少两个正整数的和。令 k 是拆分出的第一个正整数，则剩下的部分是 n−k，n−k 可以不继续拆分，或者继续拆分成至少两个正整数的和。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解。\n\n* **dp数组的含义**： dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积。\n* **边界条件**： 0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0]=dp[1]=0。\n* **状态转移方程**：当 i≥2 时，假设对正整数 i 拆分出的第一个正整数是 j（1≤j<i），则有以下两种方案：\n    * 将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j×(i−j)；\n    * 将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j×dp[i−j]。\n\n因此，当 j 固定时，有 dp[i]=max(j×(i−j),j×dp[i−j])。由于 j 的取值范围是 1 到 i−1，需要遍历所有的 j 得到 dp[i] 的最大值，因此可以得到状态转移方程如下：<br>\n<img src=\"/img/202011/002.png\" width=\"50%\" height=\"50%\">\n\n##### 数学思想\n设将长度为 n 的绳子切为 a 段：<br>\n<img src=\"/img/202011/003.png\" width=\"50%\" height=\"50%\">\n\n本题等价于求解：<br>\n<img src=\"/img/202011/004.png\" width=\"50%\" height=\"50%\">\n\n以下公式为“算术几何均值不等式” ，等号当且仅当 n1 = n2 = ... = na 时候成立：<br>\n<img src=\"/img/202011/005.png\" width=\"50%\" height=\"50%\">\n\n> 推论一： 将绳子 以相等的长度等分为多段 ，得到的乘积最大。\n\n<img src=\"/img/202011/006.png\" width=\"70%\" height=\"70%\">\n<img src=\"/img/202011/007.png\" width=\"70%\" height=\"70%\">\n<img src=\"/img/202011/008.png\" width=\"50%\" height=\"50%\">\n\n#### 结果\n\n##### 动态规划\n```java\nclass Solution {\n    public int cuttingRope(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            for (int j = 1; j < i; j++) {\n                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));\n            }\n        }\n        return dp[n];\n    }\n}\n```\n\n##### 数学思想\n```java\nclass Solution {\n    public int cuttingRope(int n) {\n        if (n <= 3) {\n            return n - 1;\n        }\n        int a = n / 3;\n        int b = n % 3;\n        if (b == 0) {\n            return (int) Math.pow(3, a);\n        }\n        if (b == 1) {\n            return (int) Math.pow(3, a - 1) * 4;\n        }\n        return (int) Math.pow(3, a) * 2;\n    }\n}\n```","tags":["算法"]},{"title":"【剑指 offer】13. 机器人的运动范围","url":"/2020/11/16/【剑指-offer】13-机器人的运动范围/","content":"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof\n### 题目描述\n地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n\n示例 1：\n\n```bash\n输入：m = 2, n = 3, k = 1\n输出：3\n```\n\n示例 2：\n```bash\n输入：m = 3, n = 1, k = 0\n输出：1\n```\n\n提示：\n\n> 1 <= n,m <= 100\n> 0 <= k <= 20\n\n### 我的解题\n#### 思路\n题目中给了一个限定条件*不能进入行坐标和列坐标的数位之和大于k的格子*，即从点（0，0）出发的机器人在这个条件内能都达到的所有方块数量，同时要注意，所有能够到达的方块都是和点（0，0）连续的，例如当k=2时候，点（100，100），光看k的值是满足的但是机器人无法到达这个点。\n\n这种涉及到连续路径查询，且只需要查询个数不需要查询具体某条路线的问题可以用广度优先搜索来完成。\n\n#### 结果\n```java\nclass Solution {\n    public int movingCount(int m, int n, int k) {\n        //广度优先搜索\n        Queue<int[]> queue = new LinkedList<>();\n        Set<String> used = new HashSet<>();\n        used.add(\"0,0\");\n        queue.add(new int[] {0, 0});\n        int[][] foots = {\n            {1, 0},\n            {-1, 0},\n            {0, 1},\n            {0, -1}\n        };\n        int count = 0;\n\n        while (!queue.isEmpty()) {\n            int[] num = queue.poll();\n            int mK = getK(num[0], num[1]);\n            if (mK > k) {\n                continue;\n            }\n\n            for (int[] foot : foots) {\n                int x = foot[0] + num[0];\n                int y = foot[1] + num[1];\n                if (x < 0 || y < 0 || x >= m || y >= n) {\n                    continue;\n                }\n                String key = x + \",\" + y;\n                if (used.contains(key)) {\n                    continue;\n                }\n                used.add(key);\n\n                if (getK(x, y) > k) {\n                    continue;\n                }\n                queue.add(new int[] {x, y});\n            }\n\n            count++;\n        }\n        return count;\n    }\n\n    private int getK(int i, int j) {\n        int sum = 0;\n        while (i > 0) {\n            int n = i % 10;\n            sum += n;\n            i /= 10;\n        }\n        while (j > 0) {\n            int n = j % 10;\n            sum += n;\n            j /= 10;\n        }\n        return sum;\n    }\n\n}\n```\n### 最优解\n#### 思路\n\n##### 思路一：广度优先搜索\n不过在\n```java\nint[][] foots = {\n    {1, 0},\n    {-1, 0},\n    {0, 1},\n    {0, -1}\n};\n```\n这一步可以用\n```java\nint[][] foots = {\n    {1, 0},\n    {0, 1}\n};\n```\n来替代，用于减少循环次数，因为机器人只会往右或下行走。\n\n##### 思路二：递推\n考虑到方法一提到搜索的方向只需要朝下或朝右，我们可以得出一种递推的求解方法。\n定义 vis[i][j] 为 (i, j) 坐标是否可达，如果可达返回 1，否则返回 0。\n首先 (i, j) 本身需要可以进入，因此需要先判断 i 和 j 的数位之和是否大于 k ，如果大于的话直接设置 vis[i][j] 为不可达即可。\n否则，前面提到搜索方向只需朝下或朝右，因此 (i, j) 的格子只会从 (i - 1, j) 或者 (i, j - 1) 两个格子走过来（不考虑边界条件），那么 vis[i][j] 是否可达的状态则可由如下公式计算得到：<br>\n> **vis[i][j]=vis[i−1][j] or vis[i][j−1]**\n\n即只要有一个格子可达，那么 (i, j) 这个格子就是可达的，因此我们只要遍历所有格子，递推计算出它们是否可达然后用变量 ans 记录可达的格子数量即可。\n初始条件 vis[i][j] = 1 ，递推计算的过程中注意边界的处理。\n\n#### 结果\n```java\nclass Solution {\n    public int movingCount(int m, int n, int k) {\n        if (k == 0) {\n            return 1;\n        }\n        boolean[][] vis = new boolean[m][n];\n        int ans = 1;\n        vis[0][0] = true;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if ((i == 0 && j == 0) || get(i) + get(j) > k) {\n                    continue;\n                }\n                // 边界判断\n                if (i - 1 >= 0) {\n                    vis[i][j] |= vis[i - 1][j];\n                }\n                if (j - 1 >= 0) {\n                    vis[i][j] |= vis[i][j - 1];\n                }\n                ans += vis[i][j] ? 1 : 0;\n            }\n        }\n        return ans;\n    }\n\n    private int get(int x) {\n        int res = 0;\n        while (x != 0) {\n            res += x % 10;\n            x /= 10;\n        }\n        return res;\n    }\n}\n```","tags":["算法"]},{"title":"【剑指 offer】12. 矩阵中的路径","url":"/2020/11/15/【剑指-offer】12-矩阵中的路径/","content":"链接：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n### 题目描述\n请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。\n\n```bash\n[[\"a\",\"b\",\"c\",\"e\"],\n[\"s\",\"f\",\"c\",\"s\"],\n[\"a\",\"d\",\"e\",\"e\"]]\n```\n\n但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。\n\n \n\n示例 1：\n\n```bash\n输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n输出：true\n```\n\n\n示例 2：\n```bash\n输入：board = [[\"a\",\"b\"],[\"c\",\"d\"]], word = \"abcd\"\n输出：false\n```\n\n提示：\n```bash\n1 <= board.length <= 200\n1 <= board[i].length <= 200\n```\n\n### 我的解题\n#### 思路\n首先想到的就是深度优先搜索，即遍历board，判断下标元素是否和word的首字符一致，如果一致则判断周围四个格子是否有字符与word的下一个字符一致。为了避免循环判断，采用一个数据结构记录已经走过的路程。\n\n#### 结果\n```java\n\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        char[] words = word.toCharArray();\n        int[][] used = new int[board.length][board[0].length];\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if (board[i][j] != words[0]) {\n                    continue;\n                }\n                if (check(board, i, j, words, 0, used)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean check(char[][] board, int i, int j, char[] words, int wordIndex, int[][] used) {\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) {\n            if (wordIndex >= words.length) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n        if (used[i][j] == 1) {\n            return false;\n        }\n        if (wordIndex >= words.length) {\n            return true;\n        }\n        if (board[i][j] != words[wordIndex]) {\n            return false;\n        }\n        used[i][j] = 1;\n        int[][] foots = {\n            {1, 0},\n            {-1, 0},\n            {0, 1},\n            {0, -1}\n        };\n        for (int[] foot : foots) {\n            int x = i + foot[0];\n            int y = j + foot[1];\n            if (check(board, x, y, words, wordIndex + 1, used)) {\n                return true;\n            }\n        }\n        used[i][j] = 0;\n        return false;\n    }\n}\n```\n### 最优解\n#### 思路\n本问题是典型的矩阵搜索问题，可使用 深度优先搜索（DFS）+ 剪枝 解决。\n\n* **深度优先搜索**： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。\n* **剪枝**： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。\n<!-- ![]() -->\n<img src=\"/img/202011/001.png\" width=\"50%\" height=\"50%\">\n\n##### DFS 解析：\n\n* **递归参数**： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。\n* **终止条件**：\n    1. 返回 falsefalse ： (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。\n    2. 返回 truetrue ： k = len(word) - 1 ，即字符串 word 已全部匹配。\n* **递推工作**：\n    1. 标记当前矩阵元素： 将 board[i][j] 修改为 空字符 '' ，代表此元素已访问过，防止之后搜索时重复访问。\n    2. 搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。\n    3. 还原当前矩阵元素： 将 board[i][j] 元素还原至初始值，即 word[k] 。\n* **返回值**： 返回布尔量 res ，代表是否搜索到目标字符串。\n\n> 使用空字符（Python: '' , Java/C++: '\\0' ）做标记是为了防止标记字符与矩阵原有字符重复。当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误。\n\n##### 复杂度分析：\n> M,N 分别为矩阵行列大小， K 为字符串 word 长度。\n\n* 时间复杂度 O(3^K * MN) : 最差情况下，需要遍历矩阵中长度为 KK 字符串的所有方案，时间复杂度为O(3^K).矩阵中共有 MN 个起点，时间复杂度为 O(MN) 。\n    * 方案数计算设字符串长度为 KK ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为O(3^K) 。\n* 空间复杂度 O(K) ： 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K = K=MN ，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。\n\n#### 结果\n```java\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        char[] words = word.toCharArray();\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board[0].length; j++) {\n                if(dfs(board, words, i, j, 0)) return true;\n            }\n        }\n        return false;\n    }\n    boolean dfs(char[][] board, char[] word, int i, int j, int k) {\n        if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]) return false;\n        if(k == word.length - 1) return true;\n        board[i][j] = '\\0';\n        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || \n                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);\n        board[i][j] = word[k];\n        return res;\n    }\n}\n```","tags":["算法"]},{"title":"【剑指 offer】07. 重建二叉树","url":"/2020/11/11/【剑指-offer】07-重建二叉树/","content":"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof\n### 题目描述\n输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n\n例如，给出\n\n> 前序遍历 preorder = [3,9,20,15,7]\n> 中序遍历 inorder = [9,3,15,20,7]\n返回如下的二叉树：\n\n```bash\n   3\n  / \\ \n 9  20 \n   /  \\ \n  15   7 \n```\n\n限制：\n\n> 0 <= 节点个数 <= 5000\n\n### 我的解题\n#### 思路\n首先确定两种遍历方式的区别：\n* 前序遍历：根节点->左节点->右节点\n* 中序遍历：左节点->根节点->右节点\n\n因此，在中序遍历中，在根节点之前被访问的节点都位于左子树，在根节点之后被访问的节点都位于右子树。同时前序遍历的数据顺序对于跟节点来说，等于如下结构【根节点】【所有左节点】【所有右节点】，因此，在通过跟节点从中序遍历中得到跟节点的左右字节点队列与个数后，能根据左右字节点的数量从前序遍历中分解出左节点队列和右节点队列，到了这步通过迭代即可遍历树。\n\n> 其实我只到两种遍历的区别，没有第一时间意识到通过宏观的角度将数组分成左右两个节点的队列，太久没有接触树的概念生疏了。\n\n#### 结果\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if (preorder == null || preorder.length == 0) {\n            return null;\n        }\n        Map<Integer, Integer> indexMap = new HashMap<Integer, Integer>();\n        int length = preorder.length;\n        for (int i = 0; i < length; i++) {\n            indexMap.put(inorder[i], i);\n        }\n        TreeNode root = buildTree(preorder, 0, length - 1, inorder, 0, length - 1, indexMap);\n        return root;\n    }\n\n    public TreeNode buildTree(int[] preorder, int preorderStart, int preorderEnd, int[] inorder, int inorderStart, int inorderEnd, Map<Integer, Integer> indexMap) {\n        if (preorderStart > preorderEnd) {\n            return null;\n        }\n        int rootVal = preorder[preorderStart];\n        TreeNode root = new TreeNode(rootVal);\n        if (preorderStart == preorderEnd) {\n            return root;\n        } else {\n            int rootIndex = indexMap.get(rootVal);\n            int leftNodes = rootIndex - inorderStart, rightNodes = inorderEnd - rootIndex;\n            TreeNode leftSubtree = buildTree(preorder, preorderStart + 1, preorderStart + leftNodes, inorder, inorderStart, rootIndex - 1, indexMap);\n            TreeNode rightSubtree = buildTree(preorder, preorderEnd - rightNodes + 1, preorderEnd, inorder, rootIndex + 1, inorderEnd, indexMap);\n            root.left = leftSubtree;\n            root.right = rightSubtree;\n            return root;\n        }\n    }\n}\n```\n ### 最优解\n #### 思路\n 第一个通过迭代的思路同上。因此这里介绍另一种方法：*迭代*。\n 例如要重建的是如下二叉树。\n\n```bash\n        3\n       / \\\n      9  20\n     /  /  \\\n    8  15   7\n   / \\\n  5  10\n /\n4\n```\n\n其前序遍历和中序遍历如下。\n\n>preorder = [3,9,8,5,4,10,20,15,7]\n>inorder = [4,5,8,10,9,3,15,20,7]\n\n前序遍历的第一个元素 3 是根节点，第二个元素 9 可能位于左子树或者右子树，需要通过中序遍历判断。\n\n中序遍历的第一个元素是 4 ，不是根节点 3，说明 9 位于左子树，因为根节点不是中序遍历中的第一个节点。同理，前序遍历的后几个元素 8、5、4 也都位于左子树，且每个节点都是其上一个节点的左子节点。\n\n前序遍历到元素 4，和中序遍历的第一个元素相等，说明前序遍历的下一个元素 10 位于右子树。那么 10 位于哪个元素的右子树？从前序遍历看，10 可能位于 4、5、8、9、3 这些元素中任何一个元素的右子树。从中序遍历看，10 在 8 的后面，因此 10 位于 8 的右子树。把前序遍历的顺序反转，则在 10 之前的元素是 4、5、8、9、3，其中 8 是最后一次相等的节点，因此前序遍历的下一个元素位于中序遍历中最后一次相等的节点的右子树。\n\n根据上述例子和分析，可以使用栈保存遍历过的节点。初始时令中序遍历的指针指向第一个元素，遍历前序遍历的数组，如果前序遍历的元素不等于中序遍历的指针指向的元素，则前序遍历的元素为上一个节点的左子节点。如果前序遍历的元素等于中序遍历的指针指向的元素，则正向遍历中序遍历的元素同时反向遍历前序遍历的元素，找到最后一次相等的元素，将前序遍历的下一个节点作为最后一次相等的元素的右子节点。其中，反向遍历前序遍历的元素可通过栈的弹出元素实现。\n\n* 使用前序遍历的第一个元素创建根节点。\n* 创建一个栈，将根节点压入栈内。\n* 初始化中序遍历下标为 0。\n* 遍历前序遍历的每个元素，判断其上一个元素（即栈顶元素）是否等于中序遍历下标指向的元素。\n    * 若上一个元素不等于中序遍历下标指向的元素，则将当前元素作为其上一个元素的左子节点，并将当前元素压入栈内。\n    * 若上一个元素等于中序遍历下标指向的元素，则从栈内弹出一个元素，同时令中序遍历下标指向下一个元素，之后继续判断栈顶元素是否等于中序遍历下标指向的元素，若相等则重复该操作，直至栈为空或者元素不相等。然后令当前元素为最后一个想等元素的右节点。\n* 遍历结束，返回根节点。\n\n#### 结果\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if (preorder == null || preorder.length == 0) {\n            return null;\n        }\n        TreeNode root = new TreeNode(preorder[0]);\n        int length = preorder.length;\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        stack.push(root);\n        int inorderIndex = 0;\n        for (int i = 1; i < length; i++) {\n            int preorderVal = preorder[i];\n            TreeNode node = stack.peek();\n            if (node.val != inorder[inorderIndex]) {\n                node.left = new TreeNode(preorderVal);\n                stack.push(node.left);\n            } else {\n                while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {\n                    node = stack.pop();\n                    inorderIndex++;\n                }\n                node.right = new TreeNode(preorderVal);\n                stack.push(node.right);\n            }\n        }\n        return root;\n    }\n}\n```","tags":["算法"]},{"title":"【剑指-offer】05.替换空格","url":"/2020/11/09/【剑指-offer】05-替换空格/","content":"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof\n### 题目描述\n请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。\n\n示例 1：\n\n> 输入：s = \"We are happy.\"\n> 输出：\"We%20are%20happy.\"\n\n限制：\n> 0 <= s 的长度 <= 10000\n\n### 我的解题\n#### 思路\n有两种方法：\n1. 调用replace库函数直接替换\n2. 遍历字符串，用if判断字符是否是空格，如果是则替换\n\n#### 结果\n我这里使用方法2\n```java\nclass Solution {\n    public String replaceSpace(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (c == ' ') {\n                sb.append(\"%20\");\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n ### 最优解\n #### 思路\n 如果想把这道题目做到极致，就不要只用额外的辅助空间了！\n当然这只是针对C++的情况下，因为在C++中，字符数组是可以在原有的基础上扩充的。\n\n首先扩充数组到每个空格替换成\"%20\"之后的大小。然后从后向前替换空格，也就是双指针法。\n\n为什么不从前往后扩充呢？如果从前往后扩充的话时间复杂度就是O(n^2)了。因为每次添加元素都要将添加元素之后的所有元素向后移动。\n\n其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。这么做有两个好处：\n1. 不用申请新数组。\n2. 从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。\n\n#### 结果\n```C++\npublic:\n    string replaceSpace(string s) {\n        int count = 0; // 统计空格的个数\n        int sOldSize = s.size();\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == ' ') {\n                count++;\n            }\n        }\n        // 扩充字符串s的大小，也就是每个空格替换成\"%20\"之后的大小\n        s.resize(s.size() + count * 2);\n        int sNewSize = s.size();\n        // 从后先前将空格替换为\"%20\"\n        for (int i = sNewSize - 1, j = sOldSize - 1; j < i; i--, j--) {\n            if (s[j] != ' ') {\n                s[i] = s[j];\n            } else {\n                s[i] = '0';\n                s[i - 1] = '2';\n                s[i - 2] = '%';\n                i -= 2;\n            }\n        }\n        return s;\n    }\n};\n```","tags":["算法"]},{"title":"【剑指 offer】03.数组中重复的数字","url":"/2020/11/08/【剑指-offer】03-数组中重复的数字/","content":"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof\n### 题目描述\n找出数组中重复的数字。\n\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n示例 1：\n> 输入：\n> [2, 3, 1, 0, 2, 5, 3]\n> 输出：2 或 3 \n> 输入：\n> [2, 3, 1, 0, 2, 5, 3]\n> 输出：2 或 3 \n \n\n限制：\n\n> 2 <= n <= 100000\n\n### 我的解题\n#### 思路\n首先，其中的数字大小限定在0～n-1的范围内，既然给定了大小，那么直接创建对应长度的数组，即*int[] list = new int[nums.length]*，然后遍历数组nums，取出结果n,并将n作为下标在list数组中+1，如果结果大于1则表示当前n重复出现。\n\n这里其实就应用了空间换时间的策略，通过创建对应length的数组来加快取值过程，当然也可以使用哈希，那么我们就需要创建Set，为了加快速度，可以在创建对象的时候传入初始容量length。\n\n#### 结果\n```java\nclass Solution {\n    public int findRepeatNumber(int[] nums) {\n        int[] list = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            int n = nums[i];\n            list[n]++;\n            if (list[n] > 1) {\n                return n;\n            }\n        }\n        return -1;\n    }\n}\n```\n ### 最优解\n #### 思路\n 由于数字大小的范围是0～n-1，刚好数数组的下标对应，我们可以通过某些操作将值与下标对应，一旦某个索引的值不是一个，则找到了重复的数组，即发生了哈希碰撞。\n #### 结果\n```java\nclass Solution {\n    public int findRepeatNumber(int[] nums) {\n        //设索引初始值为 i = 0\n        int i = 0;\n        //遍历整个数组 nums \n        while(i < nums.length) {\n            //索引 i 的值为 i,无需执行交换操作，查看下一位\n            if(nums[i] == i) {\n                i++;\n                continue;\n            }\n            //索引 nums[i] 处的值也为 nums[i]，即找到一组相同值，返回 nums[i] 即可\n            if(nums[nums[i]] == nums[i]) return nums[i];\n            //执行交换操作，目的是为了使索引与值一一对应，即索引 0 的值为 0，索引 1 的值为 1\n            int tmp = nums[i];\n            nums[i] = nums[tmp];\n            nums[tmp] = tmp;\n        }\n        //如果遍历整个数组都没有找到相同的值，返回 -1\n        return -1;\n    }\n}\n```\n### 复杂度分析\n遍历数组需要O(n)的时间。\n\n在代码中的*continue*，这表示在while的一次循环中里只有这次循环将 索引(i) 与 索引值(num[i]) 匹配到了，才会执行下一次循环。\n\n在每一次的循环过程中，索引(i) 与 索引值(num[i]) 匹配到后，在后续的循环过程中不会操作它们，所以虽然一开始的循环过程中，执行的交换操作较多，但在后续的循环过程中根本不需要再执行操作了。\n\n根据均摊复杂度分析 ，总的时间复杂度为 O(N) ，N 为数组的长度。","tags":["算法"]}]