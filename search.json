[{"title":"[LeetCode]388.文件的最长绝对路径","url":"/2020/02/15/LeetCode-388-文件的最长绝对路径/","content":"## 题目\n假设我们以下述方式将我们的文件系统抽象成一个字符串:\n\n字符串 `\"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\"` 表示:\n\n```\ndir\n    subdir1\n    subdir2\n        file.ext\n```\n目录 `dir` 包含一个空的子目录 `subdir1` 和一个包含一个文件 `file.ext` 的子目录 `subdir2` 。\n\n字符串 `\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\"` 表示:\n\n```\ndir\n    subdir1\n        file1.ext\n        subsubdir1\n    subdir2\n        subsubdir2\n            file2.ext\n```\n目录 `dir` 包含两个子目录 `subdir1` 和 `subdir2`。 `subdir1` 包含一个文件 `file1.ext` 和一个空的二级子目录 `subsubdir1`。`subdir2` 包含一个二级子目录 `subsubdir2` ，其中包含一个文件 `file2.ext`。\n\n我们致力于寻找我们文件系统中文件的最长 (按字符的数量统计) 绝对路径。例如，在上述的第二个例子中，最长路径为 `\"dir/subdir2/subsubdir2/file2.ext\"`，其长度为 32 (不包含双引号)。\n\n给定一个以上述格式表示文件系统的字符串，返回文件系统中文件的最长绝对路径的长度。 如果系统中没有文件，返回 0。\n\n说明:\n\n文件名至少存在一个 `.` 和一个扩展名。\n目录或者子目录的名字不能包含 .。\n要求时间复杂度为 `O(n)` ，其中 `n` 是输入字符串的大小。\n\n请注意，如果存在路径 `aaaaaaaaaaaaaaaaaaaaa/sth.png` 的话，那么  `a/aa/aaa/file1.txt` 就不是一个最长的路径。\n\n## 相关概念\n\n* \\n：换行\n* \\t：tab键\n\n## 思路\n\n从例子中给出来的文件系统我们可以看到是分层的。那么我们在计算的时候也可以根据层次来进行判断。\n\n例如；\n```\ndir\n    subdir1\n    subdir2\n        file.ext\n```\n* 第一层：dir\n* 第二层：subdir1，subdir2\n* 第三层：file.ext\n\n我们在遍历的时候遇到存在 `.` 的文件名时结束一次遍历并进行比较。这样我们需要保留上一层到根目录的文件路径的长度。而且不需要保留全部的上一层，只要保留当前的上一层即可，就算之前有上一层的文件夹名称大于当前文件的上一层文件夹名称，我们还有最终的绝对路径长度进行比较。而保留上一层的绝对路径长度的话我们可以用数组。\n\n而且我们通过分析例子中的字符串发现层次结构只要根据文件名前存在的 `\\t` 个数就可以进行判断。\n\n因此我们的解题方法就出来了\n> 创建数组用于保存对应层数时的绝对路径长度，将字符串根据 `\\n` 进行分组，遍历数组判断当前字符串属于哪一层，如果文件名包含 `.` 则将上一层路径长度加上当前文件名长度去和当前最大的绝对路径长度进行比较并保留最大值。如果是文件夹则将当前路径长度存入。\n\n## 解\n```java\n    public int lengthLongestPath(String input) {\n        int res = 0;\n        int[] sum = new int[input.length() + 1];\n\n        for (String s : input.split(\"\\n\")) {\n            //层数，从1开始\n            int level = s.lastIndexOf(\"\\t\") + 2;\n            //这行字符串的长度\n            int len = s.length() - level + 1;\n            \n            if (s.contains(\".\")) {\n                //已经到达文件末尾\n                res = Math.max(res, sum[level - 1] + len);\n            } else {\n                sum[level] = sum[level - 1] + len + 1;\n            }\n        }\n        return res;\n    }\n\n```","tags":["LeetCode算法题"]},{"title":"[LeetCode]389.字典序排数","url":"/2020/02/15/LeetCode-389-字典序排数/","content":"## 题目\n>给定一个整数 n, 返回从 1 到 n 的字典顺序。<br>\n例如，\n<br>给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。\n<br>请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。\n\n## 相关概念\n* 字典序:在数学中，字典或词典顺序（也称为词汇顺序，字典顺序，字母顺序或词典顺序）是基于字母顺序排列的单词按字母顺序排列的方法。 这种泛化主要在于定义有序完全有序集合（通常称为字母表）的元素的序列（通常称为计算机科学中的单词）的总顺序。\n\n## 思路\n首先我们将例子中的数字重新进行排版得到\n* 1,10,11,12,13\n* 2\n* 3\n* 4\n* 5\n* 6\n* 7\n* 8\n* 9\n\n很清晰，这里首先是有一个对数字1-9的遍历。然后看数字`1,10,11,12,13`这个例子可能不是很清楚，我们换一个`n=101`的例子`1,10,100,101,11,12,13,14,15,16,17,18,19`这里我们看到首先是对数字`1`的乘法运算，然后进行加法运算，我们将其进行拆分\n* 1,10,100\n* 100,101\n* 10,11,12,13,14,15,16,17,18,19\n\n我们可以发现这是一个典型的深度优先搜索算法，那么具体的思路如下\n>先遍历1-9获取数字的开头，然后根据给定的数字先计算乘以10之后的数字是否符合要求，如果符合要求则继续乘以10，如果不符合要求则后退到先前的结果并进行加法运算。\n\n而且进行加法运算的时候不会超过10。\n\n## 解\n```java\n    public List<Integer> lexicalOrder(int n) {\n        List<Integer> list = new ArrayList<>();\n\n        for (int i = 1; i < 10; i++) {\n            if (i <= n) {\n                list.add(i);\n            }\n            mul(i, n, list);\n        }\n\n        return list;\n    }\n\n    private void mul(int num, int n, List<Integer> list) {\n        int m = num * 10;\n        if (m <= n) {\n            list.add(m);\n            mul(m, n, list);\n        }\n\n        for (int i = 1; i < 10; i++) {\n            int sum = m + i;\n            if (sum <= n) {\n                list.add(sum);\n                mul(sum, n, list);\n            } else {\n                break;\n            }\n        }\n    }\n```","tags":["LeetCode算法题"]},{"title":"初识Vert.x","url":"/2020/02/11/初识Vert-x/","content":"\nVert.x是Eclipes公司所研发的用于在JVM上构建响应式应用程序的工具包。正如该描述所表示的一样，Vert.x并不是一个框架而是一个工具包。\n\n优点：\n* **基于事件驱动且非阻塞。**\n* **多语言支持。包括Java，JavaScript，Groovy，Ruby，Ceylon，Scala和Kotlin**\n* **轻巧。Vert.x内核约为650KB**\n* **非应用程序服务器。你可以将Vert.x运行在任何需要的地方。**\n\n缺点：\n* **难上手。异步编程跟一般的编程有许多不同。**\n\n让我们先来看一个简单的demo\n\n```java\npublic class MyVerticle extends AbstractVerticle {\n\n    @Override\n    public void start() throws Exception {\n        vertx.createHttpServer()\n                .requestHandler(req -> {\n                    req.response().end(\"hello\");\n                })\n                .listen(8080);\n    }\n}\n```\n\n```java\npublic class Start {\n    public static void main(String[] args){\n        Vertx vertx = Vertx.vertx();\n\n        vertx.deployVerticle(MyVerticle.class.getName());\n    }\n}\n```\n在运行之后会在8080端口开启一个web服务，并且会返回`\"hello\"`字符。\n\n现在让我们从这个demo开始了解Vert.x。\n\n## Vert.x部分概念\n这只是一个初步认识的文章，因此只会讲解几个常用的概念，更多的可以前往[官方文档](https://vertx.io/docs/)进行了解。当然也有翻译好的[中文文档](http://vertxchina.github.io/vertx-translation-chinese/)。\n\n### Vertx实例\nVertx实例是Vertx的控制中心，如果我们没有vertx实例的话许多事情都做不了。它是一切事物的基础，包括创建客户端和服务器、获取事件总线的引用、设置定时器等等。<br>\n\n#### Vertx创建\nvertx实例的创建也是非常简单\n```java\nVertx vertx = Vertx.vertx();\n```\n#### 配置Vertx\n我们也可以在创建vertx实例的时候指定配置项\n```java\nVertx vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(40));\n```\nVertxOptions有很多配置，包括集群、高可用、池大小等。可以在[Javadoc](https://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html)中了解相关细节。\n\n### Event Loop\nVertx使用被称之为Event Loop的线程调用我们的处理器，正如前面所说的Vertx是基于事件驱动的非阻塞工具。我们在将主要的业务逻辑通过Handler编写完成后，就是通过Event Loop进行调用。由于Vertx或我们的应用程序中没有阻塞块，因此Event Loop可以快速的将各个事件分发给对应的处理器，从而在短时间内处理大量的事件。\n>据官方所说，一个Event Loop可以在短时间内处理上千个HTTP请求。\n\n一个Event Loop只能在任意时刻运行在一个核上，如果我们希望充分利用CPU资源的话，可以对Vertx进行相关配置，使得一个Vertx实例维护多个Event Loop线程，这种方式称之**Multi-Reactor 模式**，而维护一个Event Loop线程的方式称之为**Reactor 模式**。实现Multi-Reactor 模式也非常简单\n```java\npublic class Start {\n    public static void main(String[] args){\n        Vertx vertx = Vertx.vertx(new VertxOptions()\n                .setEventLoopPoolSize(Runtime.getRuntime().availableProcessors() + 1));\n        vertx.deployVerticle(FirstVerticle.class.getName());\n    }\n}\n```\n`setEventLoopPoolSize(int)`方法即设置Event Loop线程个数。\n>线程个数为处理器个数+1的原因是当一个线程出现问题时可以有一个备用线程可以及时补上。当然也可以直接设置为处理器的个数。\n\n### Handler\n这是我们使用Vertx的时候接触最多的组件，几乎所有的业务逻辑都是编写在处理器中并让Event Loop进行调用。处理器用于处理各个相关的事件，并且是线程安全的，永远不会被并发执行。\n>可以说我们整个应用程序的逻辑都是用一个又一个处理器所组成的。而连接各个处理器的就是事件。\n\n通过前面的demo我们可以看到，程序的入口是一个继承了`AbstractVerticle`抽象类的对象，这样就使得我们所有的业务代码都处于Vertx的掌控之中，这样还有一个好处就是方便Vertx诊断你的代码执行时间，在Vertx中，如果你的某部分代码执行时间过长它会在日志中打印警告信息。就像下面这样\n```bash\n警告: Thread Thread[vert.x-eventloop-thread-0,5,main]=Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 2858 ms, time limit is 2000 ms\n```\n在Vertx中方法或者说处理器的执行时间通常在2s以内属于正常范围。超过了它会给你警告方便我们排查优化。\n\n","tags":["Java"]}]