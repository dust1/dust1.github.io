[{"title":"初识Vert.x","url":"/2020/02/11/初识Vert-x/","content":"\nVert.x是Eclipes公司所研发的用于在JVM上构建响应式应用程序的工具包。正如该描述所表示的一样，Vert.x并不是一个框架而是一个工具包。\n\n优点：\n* **基于事件驱动且非阻塞。**\n* **多语言支持。包括Java，JavaScript，Groovy，Ruby，Ceylon，Scala和Kotlin**\n* **轻巧。Vert.x内核约为650KB**\n* **非应用程序服务器。你可以将Vert.x运行在任何需要的地方。**\n\n缺点：\n* **难上手。异步编程跟一般的编程有许多不同。**\n\n让我们先来看一个简单的demo\n\n```java\npublic class MyVerticle extends AbstractVerticle {\n\n    @Override\n    public void start() throws Exception {\n        vertx.createHttpServer()\n                .requestHandler(req -> {\n                    req.response().end(\"hello\");\n                })\n                .listen(8080);\n    }\n}\n```\n\n```java\npublic class Start {\n    public static void main(String[] args){\n        Vertx vertx = Vertx.vertx();\n\n        vertx.deployVerticle(MyVerticle.class.getName());\n    }\n}\n```\n在运行之后会在8080端口开启一个web服务，并且会返回`\"hello\"`字符。\n\n现在让我们从这个demo开始了解Vert.x。\n\n## Vert.x部分概念\n这只是一个初步认识的文章，因此只会讲解几个常用的概念，更多的可以前往[官方文档](https://vertx.io/docs/)进行了解。当然也有翻译好的[中文文档](http://vertxchina.github.io/vertx-translation-chinese/)。\n\n### Vertx实例\nVertx实例是Vertx的控制中心，如果我们没有vertx实例的话许多事情都做不了。它是一切事物的基础，包括创建客户端和服务器、获取事件总线的引用、设置定时器等等。<br>\n\n#### Vertx创建\nvertx实例的创建也是非常简单\n```java\nVertx vertx = Vertx.vertx();\n```\n#### 配置Vertx\n我们也可以在创建vertx实例的时候指定配置项\n```java\nVertx vertx = Vertx.vertx(new VertxOptions().setWorkerPoolSize(40));\n```\nVertxOptions有很多配置，包括集群、高可用、池大小等。可以在[Javadoc](https://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html)中了解相关细节。\n\n### Event Loop\nVertx使用被称之为Event Loop的线程调用我们的处理器，正如前面所说的Vertx是基于事件驱动的非阻塞工具。我们在将主要的业务逻辑通过Handler编写完成后，就是通过Event Loop进行调用。由于Vertx或我们的应用程序中没有阻塞块，因此Event Loop可以快速的将各个事件分发给对应的处理器，从而在短时间内处理大量的事件。\n>据官方所说，一个Event Loop可以在短时间内处理上千个HTTP请求。\n\n一个Event Loop只能在任意时刻运行在一个核上，如果我们希望充分利用CPU资源的话，可以对Vertx进行相关配置，使得一个Vertx实例维护多个Event Loop线程，这种方式称之**Multi-Reactor 模式**，而维护一个Event Loop线程的方式称之为**Reactor 模式**。实现Multi-Reactor 模式也非常简单\n```java\npublic class Start {\n    public static void main(String[] args){\n        Vertx vertx = Vertx.vertx(new VertxOptions()\n                .setEventLoopPoolSize(Runtime.getRuntime().availableProcessors() + 1));\n        vertx.deployVerticle(FirstVerticle.class.getName());\n    }\n}\n```\n`setEventLoopPoolSize(int)`方法即设置Event Loop线程个数。\n>线程个数为处理器个数+1的原因是当一个线程出现问题时可以有一个备用线程可以及时补上。当然也可以直接设置为处理器的个数。\n\n### Handler\n这是我们使用Vertx的时候接触最多的组件，几乎所有的业务逻辑都是编写在处理器中并让Event Loop进行调用。处理器用于处理各个相关的事件，并且是线程安全的，永远不会被并发执行。\n>可以说我们整个应用程序的逻辑都是用一个又一个处理器所组成的。而连接各个处理器的就是事件。\n\n通过前面的demo我们可以看到，程序的入口是一个继承了`AbstractVerticle`抽象类的对象，这样就使得我们所有的业务代码都处于Vertx的掌控之中，这样还有一个好处就是方便Vertx诊断你的代码执行时间，在Vertx中，如果你的某部分代码执行时间过长它会在日志中打印警告信息。就像下面这样\n```bash\n警告: Thread Thread[vert.x-eventloop-thread-0,5,main]=Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 2858 ms, time limit is 2000 ms\n```\n在Vertx中方法或者说处理器的执行时间通常在2s以内属于正常范围。超过了它会给你警告方便我们排查优化。\n\n","tags":["Java"]}]