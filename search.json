[{"title":"【剑指 offer】12. 矩阵中的路径","url":"/2020/11/15/【剑指-offer】12-矩阵中的路径/","content":"链接：https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n### 题目描述\n请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。\n\n```bash\n[[\"a\",\"b\",\"c\",\"e\"],\n[\"s\",\"f\",\"c\",\"s\"],\n[\"a\",\"d\",\"e\",\"e\"]]\n```\n\n但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。\n\n \n\n示例 1：\n\n```bash\n输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\n输出：true\n```\n\n\n示例 2：\n```bash\n输入：board = [[\"a\",\"b\"],[\"c\",\"d\"]], word = \"abcd\"\n输出：false\n```\n\n提示：\n```bash\n1 <= board.length <= 200\n1 <= board[i].length <= 200\n```\n\n### 我的解题\n#### 思路\n首先想到的就是深度优先搜索，即遍历board，判断下标元素是否和word的首字符一致，如果一致则判断周围四个格子是否有字符与word的下一个字符一致。为了避免循环判断，采用一个数据结构记录已经走过的路程。\n\n#### 结果\n```java\n\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        char[] words = word.toCharArray();\n        int[][] used = new int[board.length][board[0].length];\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if (board[i][j] != words[0]) {\n                    continue;\n                }\n                if (check(board, i, j, words, 0, used)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean check(char[][] board, int i, int j, char[] words, int wordIndex, int[][] used) {\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) {\n            if (wordIndex >= words.length) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n        if (used[i][j] == 1) {\n            return false;\n        }\n        if (wordIndex >= words.length) {\n            return true;\n        }\n        if (board[i][j] != words[wordIndex]) {\n            return false;\n        }\n        used[i][j] = 1;\n        int[][] foots = {\n            {1, 0},\n            {-1, 0},\n            {0, 1},\n            {0, -1}\n        };\n        for (int[] foot : foots) {\n            int x = i + foot[0];\n            int y = j + foot[1];\n            if (check(board, x, y, words, wordIndex + 1, used)) {\n                return true;\n            }\n        }\n        used[i][j] = 0;\n        return false;\n    }\n}\n```\n### 最优解\n#### 思路\n本问题是典型的矩阵搜索问题，可使用 深度优先搜索（DFS）+ 剪枝 解决。\n\n* **深度优先搜索**： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。\n* **剪枝**： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。\n<!-- ![]() -->\n<img src=\"/img/20201115/001.png\" width=\"50%\" height=\"50%\">\n\n##### DFS 解析：\n\n* **递归参数**： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。\n* **终止条件**：\n    1. 返回 falsefalse ： (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。\n    2. 返回 truetrue ： k = len(word) - 1 ，即字符串 word 已全部匹配。\n* **递推工作**：\n    1. 标记当前矩阵元素： 将 board[i][j] 修改为 空字符 '' ，代表此元素已访问过，防止之后搜索时重复访问。\n    2. 搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 res 。\n    3. 还原当前矩阵元素： 将 board[i][j] 元素还原至初始值，即 word[k] 。\n* **返回值**： 返回布尔量 res ，代表是否搜索到目标字符串。\n\n> 使用空字符（Python: '' , Java/C++: '\\0' ）做标记是为了防止标记字符与矩阵原有字符重复。当存在重复时，此算法会将矩阵原有字符认作标记字符，从而出现错误。\n\n##### 复杂度分析：\n> M,N 分别为矩阵行列大小， K 为字符串 word 长度。\n\n* 时间复杂度 O(3^K * MN) : 最差情况下，需要遍历矩阵中长度为 KK 字符串的所有方案，时间复杂度为O(3^K).矩阵中共有 MN 个起点，时间复杂度为 O(MN) 。\n    * 方案数计算设字符串长度为 KK ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为O(3^K) 。\n* 空间复杂度 O(K) ： 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K = K=MN ，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。\n\n#### 结果\n```java\nclass Solution {\n    public boolean exist(char[][] board, String word) {\n        char[] words = word.toCharArray();\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board[0].length; j++) {\n                if(dfs(board, words, i, j, 0)) return true;\n            }\n        }\n        return false;\n    }\n    boolean dfs(char[][] board, char[] word, int i, int j, int k) {\n        if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]) return false;\n        if(k == word.length - 1) return true;\n        board[i][j] = '\\0';\n        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || \n                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);\n        board[i][j] = word[k];\n        return res;\n    }\n}\n```","tags":["算法"]},{"title":"【剑指 offer】07. 重建二叉树","url":"/2020/11/11/【剑指-offer】07-重建二叉树/","content":"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof\n### 题目描述\n输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n\n例如，给出\n\n> 前序遍历 preorder = [3,9,20,15,7]\n> 中序遍历 inorder = [9,3,15,20,7]\n返回如下的二叉树：\n\n```bash\n   3\n  / \\ \n 9  20 \n   /  \\ \n  15   7 \n```\n\n限制：\n\n> 0 <= 节点个数 <= 5000\n\n### 我的解题\n#### 思路\n首先确定两种遍历方式的区别：\n* 前序遍历：根节点->左节点->右节点\n* 中序遍历：左节点->根节点->右节点\n\n因此，在中序遍历中，在根节点之前被访问的节点都位于左子树，在根节点之后被访问的节点都位于右子树。同时前序遍历的数据顺序对于跟节点来说，等于如下结构【根节点】【所有左节点】【所有右节点】，因此，在通过跟节点从中序遍历中得到跟节点的左右字节点队列与个数后，能根据左右字节点的数量从前序遍历中分解出左节点队列和右节点队列，到了这步通过迭代即可遍历树。\n\n> 其实我只到两种遍历的区别，没有第一时间意识到通过宏观的角度将数组分成左右两个节点的队列，太久没有接触树的概念生疏了。\n\n#### 结果\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if (preorder == null || preorder.length == 0) {\n            return null;\n        }\n        Map<Integer, Integer> indexMap = new HashMap<Integer, Integer>();\n        int length = preorder.length;\n        for (int i = 0; i < length; i++) {\n            indexMap.put(inorder[i], i);\n        }\n        TreeNode root = buildTree(preorder, 0, length - 1, inorder, 0, length - 1, indexMap);\n        return root;\n    }\n\n    public TreeNode buildTree(int[] preorder, int preorderStart, int preorderEnd, int[] inorder, int inorderStart, int inorderEnd, Map<Integer, Integer> indexMap) {\n        if (preorderStart > preorderEnd) {\n            return null;\n        }\n        int rootVal = preorder[preorderStart];\n        TreeNode root = new TreeNode(rootVal);\n        if (preorderStart == preorderEnd) {\n            return root;\n        } else {\n            int rootIndex = indexMap.get(rootVal);\n            int leftNodes = rootIndex - inorderStart, rightNodes = inorderEnd - rootIndex;\n            TreeNode leftSubtree = buildTree(preorder, preorderStart + 1, preorderStart + leftNodes, inorder, inorderStart, rootIndex - 1, indexMap);\n            TreeNode rightSubtree = buildTree(preorder, preorderEnd - rightNodes + 1, preorderEnd, inorder, rootIndex + 1, inorderEnd, indexMap);\n            root.left = leftSubtree;\n            root.right = rightSubtree;\n            return root;\n        }\n    }\n}\n```\n ### 最优解\n #### 思路\n 第一个通过迭代的思路同上。因此这里介绍另一种方法：*迭代*。\n 例如要重建的是如下二叉树。\n\n```bash\n        3\n       / \\\n      9  20\n     /  /  \\\n    8  15   7\n   / \\\n  5  10\n /\n4\n```\n\n其前序遍历和中序遍历如下。\n\n>preorder = [3,9,8,5,4,10,20,15,7]\n>inorder = [4,5,8,10,9,3,15,20,7]\n\n前序遍历的第一个元素 3 是根节点，第二个元素 9 可能位于左子树或者右子树，需要通过中序遍历判断。\n\n中序遍历的第一个元素是 4 ，不是根节点 3，说明 9 位于左子树，因为根节点不是中序遍历中的第一个节点。同理，前序遍历的后几个元素 8、5、4 也都位于左子树，且每个节点都是其上一个节点的左子节点。\n\n前序遍历到元素 4，和中序遍历的第一个元素相等，说明前序遍历的下一个元素 10 位于右子树。那么 10 位于哪个元素的右子树？从前序遍历看，10 可能位于 4、5、8、9、3 这些元素中任何一个元素的右子树。从中序遍历看，10 在 8 的后面，因此 10 位于 8 的右子树。把前序遍历的顺序反转，则在 10 之前的元素是 4、5、8、9、3，其中 8 是最后一次相等的节点，因此前序遍历的下一个元素位于中序遍历中最后一次相等的节点的右子树。\n\n根据上述例子和分析，可以使用栈保存遍历过的节点。初始时令中序遍历的指针指向第一个元素，遍历前序遍历的数组，如果前序遍历的元素不等于中序遍历的指针指向的元素，则前序遍历的元素为上一个节点的左子节点。如果前序遍历的元素等于中序遍历的指针指向的元素，则正向遍历中序遍历的元素同时反向遍历前序遍历的元素，找到最后一次相等的元素，将前序遍历的下一个节点作为最后一次相等的元素的右子节点。其中，反向遍历前序遍历的元素可通过栈的弹出元素实现。\n\n* 使用前序遍历的第一个元素创建根节点。\n* 创建一个栈，将根节点压入栈内。\n* 初始化中序遍历下标为 0。\n* 遍历前序遍历的每个元素，判断其上一个元素（即栈顶元素）是否等于中序遍历下标指向的元素。\n    * 若上一个元素不等于中序遍历下标指向的元素，则将当前元素作为其上一个元素的左子节点，并将当前元素压入栈内。\n    * 若上一个元素等于中序遍历下标指向的元素，则从栈内弹出一个元素，同时令中序遍历下标指向下一个元素，之后继续判断栈顶元素是否等于中序遍历下标指向的元素，若相等则重复该操作，直至栈为空或者元素不相等。然后令当前元素为最后一个想等元素的右节点。\n* 遍历结束，返回根节点。\n\n#### 结果\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if (preorder == null || preorder.length == 0) {\n            return null;\n        }\n        TreeNode root = new TreeNode(preorder[0]);\n        int length = preorder.length;\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        stack.push(root);\n        int inorderIndex = 0;\n        for (int i = 1; i < length; i++) {\n            int preorderVal = preorder[i];\n            TreeNode node = stack.peek();\n            if (node.val != inorder[inorderIndex]) {\n                node.left = new TreeNode(preorderVal);\n                stack.push(node.left);\n            } else {\n                while (!stack.isEmpty() && stack.peek().val == inorder[inorderIndex]) {\n                    node = stack.pop();\n                    inorderIndex++;\n                }\n                node.right = new TreeNode(preorderVal);\n                stack.push(node.right);\n            }\n        }\n        return root;\n    }\n}\n```","tags":["算法"]},{"title":"【剑指-offer】05.替换空格","url":"/2020/11/09/【剑指-offer】05-替换空格/","content":"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof\n### 题目描述\n请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。\n\n示例 1：\n\n> 输入：s = \"We are happy.\"\n> 输出：\"We%20are%20happy.\"\n\n限制：\n> 0 <= s 的长度 <= 10000\n\n### 我的解题\n#### 思路\n有两种方法：\n1. 调用replace库函数直接替换\n2. 遍历字符串，用if判断字符是否是空格，如果是则替换\n\n#### 结果\n我这里使用方法2\n```java\nclass Solution {\n    public String replaceSpace(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (c == ' ') {\n                sb.append(\"%20\");\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n ### 最优解\n #### 思路\n 如果想把这道题目做到极致，就不要只用额外的辅助空间了！\n当然这只是针对C++的情况下，因为在C++中，字符数组是可以在原有的基础上扩充的。\n\n首先扩充数组到每个空格替换成\"%20\"之后的大小。然后从后向前替换空格，也就是双指针法。\n\n为什么不从前往后扩充呢？如果从前往后扩充的话时间复杂度就是O(n^2)了。因为每次添加元素都要将添加元素之后的所有元素向后移动。\n\n其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。这么做有两个好处：\n1. 不用申请新数组。\n2. 从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。\n\n#### 结果\n```C++\npublic:\n    string replaceSpace(string s) {\n        int count = 0; // 统计空格的个数\n        int sOldSize = s.size();\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == ' ') {\n                count++;\n            }\n        }\n        // 扩充字符串s的大小，也就是每个空格替换成\"%20\"之后的大小\n        s.resize(s.size() + count * 2);\n        int sNewSize = s.size();\n        // 从后先前将空格替换为\"%20\"\n        for (int i = sNewSize - 1, j = sOldSize - 1; j < i; i--, j--) {\n            if (s[j] != ' ') {\n                s[i] = s[j];\n            } else {\n                s[i] = '0';\n                s[i - 1] = '2';\n                s[i - 2] = '%';\n                i -= 2;\n            }\n        }\n        return s;\n    }\n};\n```","tags":["算法"]},{"title":"【剑指 offer】03.数组中重复的数字","url":"/2020/11/08/【剑指-offer】03-数组中重复的数字/","content":"来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof\n### 题目描述\n找出数组中重复的数字。\n\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n示例 1：\n> 输入：\n> [2, 3, 1, 0, 2, 5, 3]\n> 输出：2 或 3 \n> 输入：\n> [2, 3, 1, 0, 2, 5, 3]\n> 输出：2 或 3 \n \n\n限制：\n\n> 2 <= n <= 100000\n\n### 我的解题\n#### 思路\n首先，其中的数字大小限定在0～n-1的范围内，既然给定了大小，那么直接创建对应长度的数组，即*int[] list = new int[nums.length]*，然后遍历数组nums，取出结果n,并将n作为下标在list数组中+1，如果结果大于1则表示当前n重复出现。\n\n这里其实就应用了空间换时间的策略，通过创建对应length的数组来加快取值过程，当然也可以使用哈希，那么我们就需要创建Set，为了加快速度，可以在创建对象的时候传入初始容量length。\n\n#### 结果\n```java\nclass Solution {\n    public int findRepeatNumber(int[] nums) {\n        int[] list = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            int n = nums[i];\n            list[n]++;\n            if (list[n] > 1) {\n                return n;\n            }\n        }\n        return -1;\n    }\n}\n```\n ### 最优解\n #### 思路\n 由于数字大小的范围是0～n-1，刚好数数组的下标对应，我们可以通过某些操作将值与下标对应，一旦某个索引的值不是一个，则找到了重复的数组，即发生了哈希碰撞。\n #### 结果\n```java\nclass Solution {\n    public int findRepeatNumber(int[] nums) {\n        //设索引初始值为 i = 0\n        int i = 0;\n        //遍历整个数组 nums \n        while(i < nums.length) {\n            //索引 i 的值为 i,无需执行交换操作，查看下一位\n            if(nums[i] == i) {\n                i++;\n                continue;\n            }\n            //索引 nums[i] 处的值也为 nums[i]，即找到一组相同值，返回 nums[i] 即可\n            if(nums[nums[i]] == nums[i]) return nums[i];\n            //执行交换操作，目的是为了使索引与值一一对应，即索引 0 的值为 0，索引 1 的值为 1\n            int tmp = nums[i];\n            nums[i] = nums[tmp];\n            nums[tmp] = tmp;\n        }\n        //如果遍历整个数组都没有找到相同的值，返回 -1\n        return -1;\n    }\n}\n```\n### 复杂度分析\n遍历数组需要O(n)的时间。\n\n在代码中的*continue*，这表示在while的一次循环中里只有这次循环将 索引(i) 与 索引值(num[i]) 匹配到了，才会执行下一次循环。\n\n在每一次的循环过程中，索引(i) 与 索引值(num[i]) 匹配到后，在后续的循环过程中不会操作它们，所以虽然一开始的循环过程中，执行的交换操作较多，但在后续的循环过程中根本不需要再执行操作了。\n\n根据均摊复杂度分析 ，总的时间复杂度为 O(N) ，N 为数组的长度。","tags":["算法"]}]